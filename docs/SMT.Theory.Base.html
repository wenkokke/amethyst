<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theory.Base</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">--------------------------------------------------------------------------------</a>
<a id="82" class="Comment">-- Schmitty the Solver</a>
<a id="105" class="Comment">--</a>
<a id="108" class="Comment">-- Defines the `Theory` class. The implementation of SMT-LIB terms and scripts</a>
<a id="187" class="Comment">-- is parameterised by an instance of the `Theory` class, which determines the</a>
<a id="266" class="Comment">-- sorts, literals, and identifiers, as well as the links to the SMT-LIB version</a>
<a id="347" class="Comment">-- of the theory.</a>
<a id="365" class="Comment">--</a>
<a id="368" class="Comment">-- The `Theory` class is split up into *three* subclasses:</a>
<a id="427" class="Comment">--</a>
<a id="430" class="Comment">-- - The `BaseTheory` class provides the sorts, literals, and identifiers.</a>
<a id="505" class="Comment">--   Furthermore, it contains the machinery needed to convert models back to</a>
<a id="582" class="Comment">--   Agda terms: `Value` interprets the SMT sorts as Agda types, and `quoteSort`</a>
<a id="663" class="Comment">--   and `quoteValue` quote sorts and values to reflected Agda syntax.</a>
<a id="734" class="Comment">--</a>
<a id="737" class="Comment">--   Finally, the `interpValue` function can be used to adjust the reflected</a>
<a id="814" class="Comment">--   syntax, which can be used to keep the values in `Set`. For instance, see</a>
<a id="892" class="Comment">--   `SMT.Theories.Core.Base`.</a>
<a id="923" class="Comment">--</a>
<a id="926" class="Comment">-- - The `Printable` class provides pretty-printers, which print the sorts,</a>
<a id="1002" class="Comment">--   literals, and identifiers to their corresponding SMT-LIB terms. To help</a>
<a id="1079" class="Comment">--   define these functions, this module also exports `mkSTerm`, which prints a</a>
<a id="1159" class="Comment">--   list of strings as an S-expression.</a>
<a id="1200" class="Comment">--</a>
<a id="1203" class="Comment">-- - The `Parsable` class provides parsers, which parse the sorts and values</a>
<a id="1280" class="Comment">--   output as part of the SMT-LIB model.</a>
<a id="1322" class="Comment">--</a>
<a id="1325" class="Comment">-- The `Theory` class itself merely combines instances of all three of these</a>
<a id="1402" class="Comment">-- classes.</a>
<a id="1414" class="Comment">--------------------------------------------------------------------------------</a>

<a id="1496" class="Keyword">module</a> <a id="1503" href="SMT.Theory.Base.html" class="Module">SMT.Theory.Base</a> <a id="1519" class="Keyword">where</a>

<a id="1526" class="Keyword">open</a> <a id="1531" class="Keyword">import</a> <a id="1538" href="Level.html" class="Module">Level</a>
<a id="1544" class="Keyword">open</a> <a id="1549" class="Keyword">import</a> <a id="1556" href="Data.List.html" class="Module">Data.List</a> <a id="1566" class="Symbol">as</a> <a id="1569" class="Module">List</a> <a id="1574" class="Keyword">using</a> <a id="1580" class="Symbol">(</a><a id="1581" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="1585" class="Symbol">;</a> <a id="1587" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="1590" class="Symbol">;</a> <a id="1592" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="1594" class="Symbol">)</a>
<a id="1596" class="Keyword">open</a> <a id="1601" class="Keyword">import</a> <a id="1608" href="Data.String.html" class="Module">Data.String</a> <a id="1620" class="Symbol">as</a> <a id="1623" class="Module">String</a> <a id="1630" class="Keyword">using</a> <a id="1636" class="Symbol">(</a><a id="1637" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="1643" class="Symbol">)</a>
<a id="1645" class="Keyword">open</a> <a id="1650" class="Keyword">import</a> <a id="1657" href="Data.Maybe.html" class="Module">Data.Maybe</a> <a id="1668" class="Symbol">as</a> <a id="1671" class="Module">Maybe</a> <a id="1677" class="Keyword">using</a> <a id="1683" class="Symbol">(</a><a id="1684" href="Agda.Builtin.Maybe.html#136" class="Datatype">Maybe</a><a id="1689" class="Symbol">)</a>
<a id="1691" class="Keyword">open</a> <a id="1696" class="Keyword">import</a> <a id="1703" href="Data.Product.html" class="Module">Data.Product</a> <a id="1716" class="Symbol">as</a> <a id="1719" class="Module">Prod</a> <a id="1724" class="Keyword">using</a> <a id="1730" class="Symbol">(</a><a id="1731" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="1739" class="Symbol">)</a>
<a id="1741" class="Keyword">open</a> <a id="1746" class="Keyword">import</a> <a id="1753" href="Function.html" class="Module">Function</a> <a id="1762" class="Keyword">using</a> <a id="1768" class="Symbol">(</a><a id="1769" href="Function.Base.html#1031" class="Function Operator">_∘_</a><a id="1772" class="Symbol">)</a>
<a id="1774" class="Keyword">import</a> <a id="1781" href="Reflection.html" class="Module">Reflection</a> <a id="1792" class="Symbol">as</a> <a id="1795" class="Module">Rfl</a>
<a id="1799" class="Keyword">open</a> <a id="1804" class="Keyword">import</a> <a id="1811" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1828" class="Keyword">using</a> <a id="1834" class="Symbol">(</a><a id="1835" href="Relation.Nullary.html#1508" class="Record">Dec</a><a id="1838" class="Symbol">;</a> <a id="1840" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="1843" class="Symbol">;</a> <a id="1845" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="1847" class="Symbol">)</a>
<a id="1849" class="Keyword">open</a> <a id="1854" class="Keyword">import</a> <a id="1861" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1899" class="Keyword">using</a> <a id="1905" class="Symbol">(</a><a id="1906" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1909" class="Symbol">;</a> <a id="1911" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1915" class="Symbol">)</a>
<a id="1917" class="Keyword">open</a> <a id="1922" class="Keyword">import</a> <a id="1929" href="Text.Parser.String.html" class="Module">Text.Parser.String</a> <a id="1948" class="Keyword">using</a> <a id="1954" class="Symbol">(</a><a id="1955" href="Relation.Unary.html#3359" class="Function">IUniversal</a><a id="1965" class="Symbol">;</a> <a id="1967" href="Text.Parser.String.html#3063" class="Function">Parser</a><a id="1973" class="Symbol">)</a>


<a id="1977" class="Keyword">record</a> <a id="Signature"></a><a id="1984" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="1994" class="Symbol">{</a><a id="1995" href="SMT.Theory.Base.html#1995" class="Bound">Sort</a> <a id="2000" class="Symbol">:</a> <a id="2002" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="2005" class="Symbol">}</a> <a id="2007" class="Symbol">(</a><a id="2008" href="SMT.Theory.Base.html#2008" class="Bound">σ</a> <a id="2010" class="Symbol">:</a> <a id="2012" href="SMT.Theory.Base.html#1995" class="Bound">Sort</a><a id="2016" class="Symbol">)</a> <a id="2018" class="Symbol">:</a> <a id="2020" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="2024" class="Keyword">where</a>
  <a id="2032" class="Keyword">field</a>
    <a id="Signature.ArgSorts"></a><a id="2042" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="2051" class="Symbol">:</a> <a id="2053" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2058" href="SMT.Theory.Base.html#1995" class="Bound">Sort</a>

<a id="2064" class="Keyword">open</a> <a id="2069" href="SMT.Theory.Base.html#1984" class="Module">Signature</a> <a id="2079" class="Keyword">public</a>


<a id="2088" class="Keyword">module</a> <a id="2095" href="SMT.Theory.Base.html#2095" class="Module">_</a> <a id="2097" class="Symbol">{</a><a id="2098" href="SMT.Theory.Base.html#2098" class="Bound">Sort</a> <a id="2103" class="Symbol">:</a> <a id="2105" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="2108" class="Symbol">}</a> <a id="2110" class="Keyword">where</a>

  <a id="2119" class="Keyword">infix</a> <a id="2125" class="Number">3</a> <a id="2127" href="SMT.Theory.Base.html#2134" class="Function Operator">_↦_</a>

  <a id="2134" href="SMT.Theory.Base.html#2134" class="Function Operator">_↦_</a> <a id="2138" class="Symbol">:</a> <a id="2140" class="Symbol">(</a><a id="2141" href="SMT.Theory.Base.html#2141" class="Bound">σs</a> <a id="2144" class="Symbol">:</a> <a id="2146" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2151" href="SMT.Theory.Base.html#2098" class="Bound">Sort</a><a id="2155" class="Symbol">)</a> <a id="2157" class="Symbol">(</a><a id="2158" href="SMT.Theory.Base.html#2158" class="Bound">σ</a> <a id="2160" class="Symbol">:</a> <a id="2162" href="SMT.Theory.Base.html#2098" class="Bound">Sort</a><a id="2166" class="Symbol">)</a> <a id="2168" class="Symbol">→</a> <a id="2170" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="2180" href="SMT.Theory.Base.html#2158" class="Bound">σ</a>
  <a id="2184" href="SMT.Theory.Base.html#2184" class="Bound">Σ</a> <a id="2186" href="SMT.Theory.Base.html#2134" class="Function Operator">↦</a> <a id="2188" class="Symbol">_</a> <a id="2190" class="Symbol">=</a> <a id="2192" class="Keyword">record</a> <a id="2199" class="Symbol">{</a> <a id="2201" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="2210" class="Symbol">=</a> <a id="2212" href="SMT.Theory.Base.html#2184" class="Bound">Σ</a> <a id="2214" class="Symbol">}</a>

  <a id="2219" href="SMT.Theory.Base.html#2219" class="Function">Op₀</a> <a id="2223" class="Symbol">:</a> <a id="2225" class="Symbol">(</a><a id="2226" href="SMT.Theory.Base.html#2226" class="Bound">σ</a> <a id="2228" class="Symbol">:</a> <a id="2230" href="SMT.Theory.Base.html#2098" class="Bound">Sort</a><a id="2234" class="Symbol">)</a> <a id="2236" class="Symbol">→</a> <a id="2238" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="2248" href="SMT.Theory.Base.html#2226" class="Bound">σ</a>
  <a id="2252" href="SMT.Theory.Base.html#2219" class="Function">Op₀</a> <a id="2256" href="SMT.Theory.Base.html#2256" class="Bound">σ</a> <a id="2258" class="Symbol">=</a> <a id="2260" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2263" href="SMT.Theory.Base.html#2134" class="Function Operator">↦</a> <a id="2265" href="SMT.Theory.Base.html#2256" class="Bound">σ</a>

  <a id="2270" href="SMT.Theory.Base.html#2270" class="Function">Op₁</a> <a id="2274" class="Symbol">:</a> <a id="2276" class="Symbol">(</a><a id="2277" href="SMT.Theory.Base.html#2277" class="Bound">σ</a> <a id="2279" class="Symbol">:</a> <a id="2281" href="SMT.Theory.Base.html#2098" class="Bound">Sort</a><a id="2285" class="Symbol">)</a> <a id="2287" class="Symbol">→</a> <a id="2289" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="2299" href="SMT.Theory.Base.html#2277" class="Bound">σ</a>
  <a id="2303" href="SMT.Theory.Base.html#2270" class="Function">Op₁</a> <a id="2307" href="SMT.Theory.Base.html#2307" class="Bound">σ</a> <a id="2309" class="Symbol">=</a> <a id="2311" href="SMT.Theory.Base.html#2307" class="Bound">σ</a> <a id="2313" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2315" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2318" href="SMT.Theory.Base.html#2134" class="Function Operator">↦</a> <a id="2320" href="SMT.Theory.Base.html#2307" class="Bound">σ</a>

  <a id="2325" href="SMT.Theory.Base.html#2325" class="Function">Op₂</a> <a id="2329" class="Symbol">:</a> <a id="2331" class="Symbol">(</a><a id="2332" href="SMT.Theory.Base.html#2332" class="Bound">σ</a> <a id="2334" class="Symbol">:</a> <a id="2336" href="SMT.Theory.Base.html#2098" class="Bound">Sort</a><a id="2340" class="Symbol">)</a> <a id="2342" class="Symbol">→</a> <a id="2344" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="2354" href="SMT.Theory.Base.html#2332" class="Bound">σ</a>
  <a id="2358" href="SMT.Theory.Base.html#2325" class="Function">Op₂</a> <a id="2362" href="SMT.Theory.Base.html#2362" class="Bound">σ</a> <a id="2364" class="Symbol">=</a> <a id="2366" href="SMT.Theory.Base.html#2362" class="Bound">σ</a> <a id="2368" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2370" href="SMT.Theory.Base.html#2362" class="Bound">σ</a> <a id="2372" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2374" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="2377" href="SMT.Theory.Base.html#2134" class="Function Operator">↦</a> <a id="2379" href="SMT.Theory.Base.html#2362" class="Bound">σ</a>

  <a id="2384" href="SMT.Theory.Base.html#2384" class="Function">map</a> <a id="2388" class="Symbol">:</a> <a id="2390" class="Symbol">{</a><a id="2391" href="SMT.Theory.Base.html#2391" class="Bound">CoreSort</a> <a id="2400" class="Symbol">:</a> <a id="2402" href="Agda.Primitive.html#326" class="Primitive">Set</a><a id="2405" class="Symbol">}</a> <a id="2407" class="Symbol">{</a><a id="2408" href="SMT.Theory.Base.html#2408" class="Bound">φ</a> <a id="2410" class="Symbol">:</a> <a id="2412" href="SMT.Theory.Base.html#2391" class="Bound">CoreSort</a><a id="2420" class="Symbol">}</a> <a id="2422" class="Symbol">(</a><a id="2423" href="SMT.Theory.Base.html#2423" class="Bound">CORE</a> <a id="2428" class="Symbol">:</a> <a id="2430" href="SMT.Theory.Base.html#2391" class="Bound">CoreSort</a> <a id="2439" class="Symbol">→</a> <a id="2441" href="SMT.Theory.Base.html#2098" class="Bound">Sort</a><a id="2445" class="Symbol">)</a> <a id="2447" class="Symbol">→</a> <a id="2449" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="2459" href="SMT.Theory.Base.html#2408" class="Bound">φ</a> <a id="2461" class="Symbol">→</a> <a id="2463" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="2473" class="Symbol">(</a><a id="2474" href="SMT.Theory.Base.html#2423" class="Bound">CORE</a> <a id="2479" href="SMT.Theory.Base.html#2408" class="Bound">φ</a><a id="2480" class="Symbol">)</a>
  <a id="2484" href="SMT.Theory.Base.html#2384" class="Function">map</a> <a id="2488" href="SMT.Theory.Base.html#2488" class="Bound">CORE</a> <a id="2493" href="SMT.Theory.Base.html#2493" class="Bound">Φ</a> <a id="2495" class="Symbol">=</a> <a id="2497" class="Keyword">record</a> <a id="2504" class="Symbol">{</a> <a id="2506" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="2515" class="Symbol">=</a> <a id="2517" href="Data.List.Base.html#1497" class="Function">List.map</a> <a id="2526" href="SMT.Theory.Base.html#2488" class="Bound">CORE</a> <a id="2531" class="Symbol">(</a><a id="2532" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="2541" href="SMT.Theory.Base.html#2493" class="Bound">Φ</a><a id="2542" class="Symbol">)</a> <a id="2544" class="Symbol">}</a>


<a id="2548" class="Keyword">record</a> <a id="BaseTheory"></a><a id="2555" href="SMT.Theory.Base.html#2555" class="Record">BaseTheory</a> <a id="2566" class="Symbol">:</a> <a id="2568" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="2573" class="Keyword">where</a>
  <a id="2581" class="Keyword">field</a>
    <a id="BaseTheory.Sort"></a><a id="2591" href="SMT.Theory.Base.html#2591" class="Field">Sort</a>          <a id="2605" class="Symbol">:</a> <a id="2607" href="Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="BaseTheory._≟-Sort_"></a><a id="2615" href="SMT.Theory.Base.html#2615" class="Field Operator">_≟-Sort_</a>      <a id="2629" class="Symbol">:</a> <a id="2631" class="Symbol">(</a><a id="2632" href="SMT.Theory.Base.html#2632" class="Bound">σ</a> <a id="2634" href="SMT.Theory.Base.html#2634" class="Bound">σ′</a> <a id="2637" class="Symbol">:</a> <a id="2639" href="SMT.Theory.Base.html#2591" class="Field">Sort</a><a id="2643" class="Symbol">)</a> <a id="2645" class="Symbol">→</a> <a id="2647" href="Relation.Nullary.html#1508" class="Record">Dec</a> <a id="2651" class="Symbol">(</a><a id="2652" href="SMT.Theory.Base.html#2632" class="Bound">σ</a> <a id="2654" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">≡</a> <a id="2656" href="SMT.Theory.Base.html#2634" class="Bound">σ′</a><a id="2658" class="Symbol">)</a>
    <a id="BaseTheory.BOOL"></a><a id="2664" href="SMT.Theory.Base.html#2664" class="Field">BOOL</a>          <a id="2678" class="Symbol">:</a> <a id="2680" href="SMT.Theory.Base.html#2591" class="Field">Sort</a>
    <a id="BaseTheory.Literal"></a><a id="2689" href="SMT.Theory.Base.html#2689" class="Field">Literal</a>       <a id="2703" class="Symbol">:</a> <a id="2705" href="SMT.Theory.Base.html#2591" class="Field">Sort</a> <a id="2710" class="Symbol">→</a> <a id="2712" href="Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="BaseTheory.Identifier"></a><a id="2720" href="SMT.Theory.Base.html#2720" class="Field">Identifier</a>    <a id="2734" class="Symbol">:</a> <a id="2736" class="Symbol">{</a><a id="2737" href="SMT.Theory.Base.html#2737" class="Bound">σ</a> <a id="2739" class="Symbol">:</a> <a id="2741" href="SMT.Theory.Base.html#2591" class="Field">Sort</a><a id="2745" class="Symbol">}</a> <a id="2747" class="Symbol">→</a> <a id="2749" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="2759" href="SMT.Theory.Base.html#2737" class="Bound">σ</a> <a id="2761" class="Symbol">→</a> <a id="2763" href="Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="BaseTheory.quoteSort"></a><a id="2771" href="SMT.Theory.Base.html#2771" class="Field">quoteSort</a>     <a id="2785" class="Symbol">:</a> <a id="2787" href="SMT.Theory.Base.html#2591" class="Field">Sort</a> <a id="2792" class="Symbol">→</a> <a id="2794" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a>

    <a id="2808" class="Comment">-- The Value family encodes which Agda map interprets the values returned as</a>
    <a id="2889" class="Comment">-- part of a model:</a>
    <a id="2913" class="Comment">--</a>
    <a id="2920" class="Comment">--   * If the Agda equivalent is in Set₀, Value should return the type</a>
    <a id="2995" class="Comment">--     directly, and interpValue should be the identity function.</a>
    <a id="3065" class="Comment">--</a>
    <a id="3072" class="Comment">--   * If the Agda equivalent is *not* in Set₀, Value should return a</a>
    <a id="3146" class="Comment">--     universe encoding of the possible return values, and interpValue</a>
    <a id="3222" class="Comment">--     should map the elements of that universe encoding to their intended</a>
    <a id="3301" class="Comment">--     interpretation.</a>
    <a id="3328" class="Comment">--</a>
    <a id="BaseTheory.Value"></a><a id="3335" href="SMT.Theory.Base.html#3335" class="Field">Value</a>       <a id="3347" class="Symbol">:</a> <a id="3349" href="SMT.Theory.Base.html#2591" class="Field">Sort</a> <a id="3354" class="Symbol">→</a> <a id="3356" href="Agda.Primitive.html#326" class="Primitive">Set</a>
    <a id="BaseTheory.quoteValue"></a><a id="3364" href="SMT.Theory.Base.html#3364" class="Field">quoteValue</a>  <a id="3376" class="Symbol">:</a> <a id="3378" class="Symbol">(</a><a id="3379" href="SMT.Theory.Base.html#3379" class="Bound">σ</a> <a id="3381" class="Symbol">:</a> <a id="3383" href="SMT.Theory.Base.html#2591" class="Field">Sort</a><a id="3387" class="Symbol">)</a> <a id="3389" class="Symbol">→</a> <a id="3391" href="SMT.Theory.Base.html#3335" class="Field">Value</a> <a id="3397" href="SMT.Theory.Base.html#3379" class="Bound">σ</a> <a id="3399" class="Symbol">→</a> <a id="3401" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a>
    <a id="BaseTheory.interpValue"></a><a id="3414" href="SMT.Theory.Base.html#3414" class="Field">interpValue</a> <a id="3426" class="Symbol">:</a> <a id="3428" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a> <a id="3437" class="Symbol">→</a> <a id="3439" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Rfl.Term</a>

<a id="3449" class="Keyword">record</a> <a id="Printable"></a><a id="3456" href="SMT.Theory.Base.html#3456" class="Record">Printable</a> <a id="3466" class="Symbol">(</a><a id="3467" href="SMT.Theory.Base.html#3467" class="Bound">baseTheory</a> <a id="3478" class="Symbol">:</a> <a id="3480" href="SMT.Theory.Base.html#2555" class="Record">BaseTheory</a><a id="3490" class="Symbol">)</a> <a id="3492" class="Symbol">:</a> <a id="3494" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="3498" class="Keyword">where</a>
  <a id="3506" class="Keyword">open</a> <a id="3511" href="SMT.Theory.Base.html#2555" class="Module">BaseTheory</a> <a id="3522" href="SMT.Theory.Base.html#3467" class="Bound">baseTheory</a>
  <a id="3535" class="Keyword">field</a>
    <a id="Printable.showSort"></a><a id="3545" href="SMT.Theory.Base.html#3545" class="Field">showSort</a>       <a id="3560" class="Symbol">:</a> <a id="3562" href="SMT.Theory.Base.html#2591" class="Function">Sort</a> <a id="3567" class="Symbol">→</a> <a id="3569" href="Agda.Builtin.String.html#336" class="Postulate">String</a>
    <a id="Printable.showLiteral"></a><a id="3580" href="SMT.Theory.Base.html#3580" class="Field">showLiteral</a>    <a id="3595" class="Symbol">:</a> <a id="3597" class="Symbol">{</a><a id="3598" href="SMT.Theory.Base.html#3598" class="Bound">σ</a> <a id="3600" class="Symbol">:</a> <a id="3602" href="SMT.Theory.Base.html#2591" class="Function">Sort</a><a id="3606" class="Symbol">}</a> <a id="3608" class="Symbol">→</a> <a id="3610" href="SMT.Theory.Base.html#2689" class="Function">Literal</a> <a id="3618" href="SMT.Theory.Base.html#3598" class="Bound">σ</a> <a id="3620" class="Symbol">→</a> <a id="3622" href="Agda.Builtin.String.html#336" class="Postulate">String</a>
    <a id="Printable.showIdentifier"></a><a id="3633" href="SMT.Theory.Base.html#3633" class="Field">showIdentifier</a> <a id="3648" class="Symbol">:</a> <a id="3650" class="Symbol">{</a><a id="3651" href="SMT.Theory.Base.html#3651" class="Bound">σ</a> <a id="3653" class="Symbol">:</a> <a id="3655" href="SMT.Theory.Base.html#2591" class="Function">Sort</a><a id="3659" class="Symbol">}</a> <a id="3661" class="Symbol">{</a><a id="3662" href="SMT.Theory.Base.html#3662" class="Bound">Σ</a> <a id="3664" class="Symbol">:</a> <a id="3666" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="3676" href="SMT.Theory.Base.html#3651" class="Bound">σ</a><a id="3677" class="Symbol">}</a> <a id="3679" class="Symbol">→</a> <a id="3681" href="SMT.Theory.Base.html#2720" class="Function">Identifier</a> <a id="3692" href="SMT.Theory.Base.html#3662" class="Bound">Σ</a> <a id="3694" class="Symbol">→</a> <a id="3696" href="Agda.Builtin.String.html#336" class="Postulate">String</a>

<a id="3704" class="Keyword">record</a> <a id="Parsable"></a><a id="3711" href="SMT.Theory.Base.html#3711" class="Record">Parsable</a> <a id="3720" class="Symbol">(</a><a id="3721" href="SMT.Theory.Base.html#3721" class="Bound">baseTheory</a> <a id="3732" class="Symbol">:</a> <a id="3734" href="SMT.Theory.Base.html#2555" class="Record">BaseTheory</a><a id="3744" class="Symbol">)</a> <a id="3746" class="Symbol">:</a> <a id="3748" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="3753" class="Keyword">where</a>
  <a id="3761" class="Keyword">open</a> <a id="3766" href="SMT.Theory.Base.html#2555" class="Module">BaseTheory</a> <a id="3777" href="SMT.Theory.Base.html#3721" class="Bound">baseTheory</a>
  <a id="3790" class="Keyword">field</a>
    <a id="Parsable.parseSort"></a><a id="3800" href="SMT.Theory.Base.html#3800" class="Field">parseSort</a>  <a id="3811" class="Symbol">:</a> <a id="3813" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="3816" href="Text.Parser.String.html#3063" class="Function">Parser</a> <a id="3823" href="SMT.Theory.Base.html#2591" class="Function">Sort</a> <a id="3828" href="Relation.Unary.html#3359" class="Function">]</a>
    <a id="Parsable.parseValue"></a><a id="3834" href="SMT.Theory.Base.html#3834" class="Field">parseValue</a> <a id="3845" class="Symbol">:</a> <a id="3847" class="Symbol">(</a><a id="3848" href="SMT.Theory.Base.html#3848" class="Bound">σ</a> <a id="3850" class="Symbol">:</a> <a id="3852" href="SMT.Theory.Base.html#2591" class="Function">Sort</a><a id="3856" class="Symbol">)</a> <a id="3858" class="Symbol">→</a> <a id="3860" href="Relation.Unary.html#3359" class="Function">∀[</a> <a id="3863" href="Text.Parser.String.html#3063" class="Function">Parser</a> <a id="3870" class="Symbol">(</a><a id="3871" href="SMT.Theory.Base.html#3335" class="Function">Value</a> <a id="3877" href="SMT.Theory.Base.html#3848" class="Bound">σ</a><a id="3878" class="Symbol">)</a> <a id="3880" href="Relation.Unary.html#3359" class="Function">]</a>

<a id="3883" class="Keyword">record</a> <a id="Theory"></a><a id="3890" href="SMT.Theory.Base.html#3890" class="Record">Theory</a> <a id="3897" class="Symbol">:</a> <a id="3899" href="Agda.Primitive.html#326" class="Primitive">Set₁</a> <a id="3904" class="Keyword">where</a>
  <a id="3912" class="Keyword">field</a>
    <a id="Theory.baseTheory"></a><a id="3922" href="SMT.Theory.Base.html#3922" class="Field">baseTheory</a>  <a id="3934" class="Symbol">:</a> <a id="3936" href="SMT.Theory.Base.html#2555" class="Record">BaseTheory</a>
    <a id="Theory.printable"></a><a id="3951" href="SMT.Theory.Base.html#3951" class="Field">printable</a>   <a id="3963" class="Symbol">:</a> <a id="3965" href="SMT.Theory.Base.html#3456" class="Record">Printable</a>   <a id="3977" href="SMT.Theory.Base.html#3922" class="Field">baseTheory</a>
    <a id="Theory.parsable"></a><a id="3992" href="SMT.Theory.Base.html#3992" class="Field">parsable</a>    <a id="4004" class="Symbol">:</a> <a id="4006" href="SMT.Theory.Base.html#3711" class="Record">Parsable</a>    <a id="4018" href="SMT.Theory.Base.html#3922" class="Field">baseTheory</a>

  <a id="4032" class="Keyword">open</a> <a id="4037" href="SMT.Theory.Base.html#2555" class="Module">BaseTheory</a>  <a id="4049" href="SMT.Theory.Base.html#3922" class="Field">baseTheory</a>  <a id="4061" class="Keyword">public</a>
  <a id="4070" class="Keyword">open</a> <a id="4075" href="SMT.Theory.Base.html#3456" class="Module">Printable</a>   <a id="4087" href="SMT.Theory.Base.html#3951" class="Field">printable</a>   <a id="4099" class="Keyword">public</a>
  <a id="4108" class="Keyword">open</a> <a id="4113" href="SMT.Theory.Base.html#3711" class="Module">Parsable</a>    <a id="4125" href="SMT.Theory.Base.html#3992" class="Field">parsable</a>    <a id="4137" class="Keyword">public</a>


<a id="4146" class="Comment">-----------------------</a>
<a id="4170" class="Comment">-- Printer utilities --</a>
<a id="4194" class="Comment">-----------------------</a>

<a id="4219" class="Comment">-- |Create an S-expression from a list of strings.</a>
<a id="4270" class="Comment">--</a>
<a id="4273" class="Comment">-- @</a>
<a id="4278" class="Comment">--   mkSTerm (&quot;*&quot; ∷ &quot;4&quot; ∷ &quot;5&quot;) ≡ &quot;(* 4 5)&quot;</a>
<a id="4321" class="Comment">-- @</a>
<a id="4326" class="Comment">--</a>
<a id="mkSTerm"></a><a id="4329" href="SMT.Theory.Base.html#4329" class="Function">mkSTerm</a> <a id="4337" class="Symbol">:</a> <a id="4339" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="4344" href="Agda.Builtin.String.html#336" class="Postulate">String</a> <a id="4351" class="Symbol">→</a> <a id="4353" href="Agda.Builtin.String.html#336" class="Postulate">String</a>
<a id="4360" href="SMT.Theory.Base.html#4329" class="Function">mkSTerm</a> <a id="4368" class="Symbol">=</a> <a id="4370" href="Data.String.Base.html#2863" class="Function">String.parens</a> <a id="4384" href="Function.Base.html#1031" class="Function Operator">∘</a> <a id="4386" href="Data.String.Base.html#2805" class="Function">String.unwords</a>
</pre></body></html>