<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theory.Raw.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Comment">--------------------------------------------------------------------------------</a>
<a id="82" class="Comment">-- Schmitty the Solver</a>
<a id="105" class="Comment">--</a>
<a id="108" class="Comment">-- Defines `reflectToRawScript`, which converts reflected Agda syntax to scripts</a>
<a id="189" class="Comment">-- in the raw theory.</a>
<a id="211" class="Comment">--------------------------------------------------------------------------------</a>

<a id="293" class="Keyword">module</a> <a id="300" href="SMT.Theory.Raw.Reflection.html" class="Module">SMT.Theory.Raw.Reflection</a> <a id="326" class="Keyword">where</a>

<a id="333" class="Keyword">open</a> <a id="338" class="Keyword">import</a> <a id="345" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="360" class="Keyword">open</a> <a id="365" class="Keyword">import</a> <a id="372" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="382" class="Symbol">as</a> <a id="385" class="Module">Bool</a> <a id="390" class="Keyword">using</a> <a id="396" class="Symbol">(</a><a id="397" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="401" class="Symbol">;</a> <a id="403" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="407" class="Symbol">;</a> <a id="409" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="414" class="Symbol">)</a>
<a id="416" class="Keyword">open</a> <a id="421" class="Keyword">import</a> <a id="428" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="437" class="Symbol">as</a> <a id="440" class="Module">Fin</a> <a id="444" class="Keyword">using</a> <a id="450" class="Symbol">(</a><a id="451" href="Data.Fin.Base.html#1138" class="Datatype">Fin</a><a id="454" class="Symbol">;</a> <a id="456" href="Data.Fin.Base.html#1191" class="InductiveConstructor">suc</a><a id="459" class="Symbol">;</a> <a id="461" href="Data.Fin.Base.html#1160" class="InductiveConstructor">zero</a><a id="465" class="Symbol">)</a>
<a id="467" class="Keyword">open</a> <a id="472" class="Keyword">import</a> <a id="479" href="Data.Integer.html" class="Module">Data.Integer</a> <a id="492" class="Symbol">as</a> <a id="495" class="Module">Int</a> <a id="499" class="Keyword">using</a> <a id="505" class="Symbol">(</a><a id="506" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a><a id="507" class="Symbol">;</a> <a id="509" href="Agda.Builtin.Int.html#264" class="InductiveConstructor">+_</a><a id="511" class="Symbol">;</a> <a id="513" href="Agda.Builtin.Int.html#291" class="InductiveConstructor">-[1+_]</a><a id="519" class="Symbol">)</a>
<a id="521" class="Keyword">open</a> <a id="526" class="Keyword">import</a> <a id="533" href="Data.List.html" class="Module">Data.List</a> <a id="543" class="Symbol">as</a> <a id="546" class="Module">List</a> <a id="551" class="Keyword">using</a> <a id="557" class="Symbol">(</a><a id="558" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="562" class="Symbol">;</a> <a id="564" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="567" class="Symbol">;</a> <a id="569" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="571" class="Symbol">)</a>
<a id="573" class="Keyword">open</a> <a id="578" class="Keyword">import</a> <a id="585" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="614" class="Keyword">using</a> <a id="620" class="Symbol">(</a><a id="621" href="Data.List.Relation.Unary.All.html#1397" class="Datatype">All</a><a id="624" class="Symbol">;</a> <a id="626" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">_∷_</a><a id="629" class="Symbol">;</a> <a id="631" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="633" class="Symbol">)</a>
<a id="635" class="Keyword">open</a> <a id="640" class="Keyword">import</a> <a id="647" href="Data.List.Relation.Unary.Any.html" class="Module">Data.List.Relation.Unary.Any</a> <a id="676" class="Keyword">using</a> <a id="682" class="Symbol">(</a><a id="683" href="Data.List.Relation.Unary.Any.html#1174" class="InductiveConstructor">here</a><a id="687" class="Symbol">;</a> <a id="689" href="Data.List.Relation.Unary.Any.html#1227" class="InductiveConstructor">there</a><a id="694" class="Symbol">)</a>
<a id="696" class="Keyword">open</a> <a id="701" class="Keyword">import</a> <a id="708" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="727" class="Symbol">as</a> <a id="730" class="Module">List⁺</a> <a id="736" class="Keyword">using</a> <a id="742" class="Symbol">(</a><a id="743" href="Data.List.NonEmpty.html#1318" class="Record">List⁺</a><a id="748" class="Symbol">;</a> <a id="750" href="Data.List.NonEmpty.html#1364" class="InductiveConstructor Operator">_∷_</a><a id="753" class="Symbol">)</a>
<a id="755" class="Keyword">open</a> <a id="760" class="Keyword">import</a> <a id="767" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="776" class="Symbol">as</a> <a id="779" class="Module">Nat</a> <a id="783" class="Keyword">using</a> <a id="789" class="Symbol">(</a><a id="790" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="791" class="Symbol">;</a> <a id="793" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="797" class="Symbol">;</a> <a id="799" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="802" class="Symbol">;</a> <a id="804" href="Data.Nat.Base.html#2869" class="Primitive Operator">_∸_</a><a id="807" class="Symbol">)</a>
<a id="809" class="Keyword">import</a> <a id="816" href="Data.Nat.Literals.html" class="Module">Data.Nat.Literals</a> <a id="834" class="Symbol">as</a> <a id="837" class="Module">NatLits</a> <a id="845" class="Keyword">using</a> <a id="851" class="Symbol">(</a><a id="852" href="Data.Nat.Literals.html#353" class="Function">number</a><a id="858" class="Symbol">)</a>
<a id="860" class="Keyword">open</a> <a id="865" class="Keyword">import</a> <a id="872" href="Data.Product.html" class="Module">Data.Product</a> <a id="885" class="Symbol">as</a> <a id="888" class="Module">Prod</a> <a id="893" class="Keyword">using</a> <a id="899" class="Symbol">(</a><a id="900" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="901" class="Symbol">;</a> <a id="903" href="Data.Product.html#1369" class="Function">∃</a><a id="904" class="Symbol">;</a> <a id="906" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="914" class="Symbol">;</a> <a id="916" href="Data.Product.html#1806" class="Function">∃-syntax</a><a id="924" class="Symbol">;</a> <a id="926" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="929" class="Symbol">;</a> <a id="931" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="934" class="Symbol">;</a> <a id="936" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="941" class="Symbol">;</a> <a id="943" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="948" class="Symbol">)</a>
<a id="950" class="Keyword">open</a> <a id="955" class="Keyword">import</a> <a id="962" href="Data.String.html" class="Module">Data.String</a> <a id="974" class="Keyword">using</a> <a id="980" class="Symbol">(</a><a id="981" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="987" class="Symbol">)</a>
<a id="989" class="Keyword">open</a> <a id="994" class="Keyword">import</a> <a id="1001" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="1011" class="Symbol">as</a> <a id="1014" class="Module">Unit</a> <a id="1019" class="Keyword">using</a> <a id="1025" class="Symbol">(</a><a id="1026" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="1027" class="Symbol">)</a>
<a id="1029" class="Keyword">open</a> <a id="1034" class="Keyword">import</a> <a id="1041" href="Function.html" class="Module">Function</a>
<a id="1050" class="Keyword">open</a> <a id="1055" class="Keyword">import</a> <a id="1062" href="Level.html" class="Module">Level</a> <a id="1068" class="Keyword">using</a> <a id="1074" class="Symbol">(</a><a id="1075" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="1080" class="Symbol">)</a>
<a id="1082" class="Keyword">open</a> <a id="1087" class="Keyword">import</a> <a id="1094" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="1132" class="Symbol">as</a> <a id="1135" class="Module">PropEq</a> <a id="1142" class="Keyword">using</a> <a id="1148" class="Symbol">(</a><a id="1149" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="1152" class="Symbol">;</a> <a id="1154" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1158" class="Symbol">)</a>
<a id="1160" class="Keyword">open</a> <a id="1165" class="Keyword">import</a> <a id="1172" href="Reflection.html" class="Module">Reflection</a> <a id="1183" class="Symbol">as</a> <a id="1186" class="Module">Rfl</a> <a id="1190" class="Keyword">hiding</a> <a id="1197" class="Symbol">(</a><a id="1198" href="Agda.Builtin.Reflection.html#7543" class="Postulate">return</a><a id="1204" class="Symbol">;</a> <a id="1206" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">_&gt;&gt;=_</a><a id="1211" class="Symbol">)</a>
<a id="1213" class="Keyword">import</a> <a id="1220" href="Reflection.TypeChecking.Monad.Categorical.html" class="Module">Reflection.TypeChecking.Monad.Categorical</a> <a id="1262" class="Symbol">as</a> <a id="1265" class="Module">TC</a>
<a id="1268" class="Keyword">open</a> <a id="1273" class="Keyword">import</a> <a id="1280" href="Reflection.DeBruijn.html" class="Module">Reflection.DeBruijn</a> <a id="1300" class="Keyword">using</a> <a id="1306" class="Symbol">(</a><a id="1307" href="Reflection.DeBruijn.html#1949" class="Function">η-expand</a><a id="1315" class="Symbol">;</a> <a id="1317" href="Reflection.DeBruijn.html#3864" class="Function Operator">_∈FV_</a><a id="1322" class="Symbol">)</a>
<a id="1324" class="Keyword">open</a> <a id="1329" class="Keyword">import</a> <a id="1336" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1353" class="Keyword">using</a> <a id="1359" class="Symbol">(</a><a id="1360" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="1362" class="Symbol">;</a> <a id="1364" href="Relation.Nullary.html#1508" class="Record">Dec</a><a id="1367" class="Symbol">;</a> <a id="1369" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="1372" class="Symbol">;</a> <a id="1374" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="1376" class="Symbol">)</a>
<a id="1378" class="Keyword">open</a> <a id="1383" class="Keyword">import</a> <a id="1390" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="1417" class="Keyword">using</a> <a id="1423" class="Symbol">(</a><a id="1424" href="Relation.Nullary.Decidable.Core.html#1027" class="Function">isYes</a><a id="1429" class="Symbol">)</a>
<a id="1431" class="Keyword">open</a> <a id="1436" class="Keyword">import</a> <a id="1443" href="SMT.Theory.html" class="Module">SMT.Theory</a>
<a id="1454" class="Keyword">open</a> <a id="1459" class="Keyword">import</a> <a id="1466" href="SMT.Theory.Raw.Base.html" class="Module">SMT.Theory.Raw.Base</a>

<a id="1487" class="Keyword">open</a> <a id="1492" class="Keyword">import</a> <a id="1499" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a>
<a id="1520" class="Keyword">open</a> <a id="1525" class="Keyword">import</a> <a id="1532" href="Agda.Builtin.FromNeg.html" class="Module">Agda.Builtin.FromNeg</a>

<a id="1554" class="Keyword">instance</a> <a id="1563" href="SMT.Theory.Raw.Reflection.html#1563" class="Function">_</a> <a id="1565" class="Symbol">=</a> <a id="1567" href="Data.Nat.Literals.html#353" class="Function">NatLits.number</a>

<a id="1583" class="Keyword">private</a>
  <a id="1593" class="Keyword">open</a> <a id="1598" class="Keyword">module</a> <a id="TCMonad"></a><a id="1605" href="SMT.Theory.Raw.Reflection.html#1605" class="Module">TCMonad</a> <a id="1613" class="Symbol">{</a><a id="1614" href="SMT.Theory.Raw.Reflection.html#1614" class="Bound">ℓ</a><a id="1615" class="Symbol">}</a> <a id="1617" class="Symbol">=</a> <a id="1619" href="Category.Monad.html#832" class="Module">Category.Monad.RawMonad</a> <a id="1643" class="Symbol">{</a><a id="1644" href="SMT.Theory.Raw.Reflection.html#1614" class="Bound">ℓ</a><a id="1645" class="Symbol">}</a> <a id="1647" href="Reflection.TypeChecking.Monad.Categorical.html#1061" class="Function">TC.monad</a> <a id="1656" class="Keyword">renaming</a> <a id="1665" class="Symbol">(</a><a id="1666" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="1670" class="Symbol">to</a> <a id="1673" class="Function Operator">_&lt;*&gt;_</a><a id="1678" class="Symbol">)</a>

<a id="1681" class="Keyword">private</a>
  <a id="1691" class="Keyword">variable</a>
    <a id="1704" href="SMT.Theory.Raw.Reflection.html#1704" class="Generalizable">ℓ</a> <a id="1706" class="Symbol">:</a> <a id="1708" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="1718" href="SMT.Theory.Raw.Reflection.html#1718" class="Generalizable">A</a> <a id="1720" class="Symbol">:</a> <a id="1722" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1726" href="SMT.Theory.Raw.Reflection.html#1704" class="Generalizable">ℓ</a>


<a id="1730" class="Keyword">private</a>
  <a id="1740" class="Comment">-- We don&#39;t know the type of raw function symbols, so just look at</a>
  <a id="1809" class="Comment">-- the arguments. Design decision: only keep visible arguments.</a>
  <a id="argTypes"></a><a id="1875" href="SMT.Theory.Raw.Reflection.html#1875" class="Function">argTypes</a> <a id="1884" class="Symbol">:</a> <a id="1886" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1891" class="Symbol">(</a><a id="1892" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="1896" href="SMT.Theory.Raw.Reflection.html#1718" class="Generalizable">A</a><a id="1897" class="Symbol">)</a> <a id="1899" class="Symbol">→</a> <a id="1901" href="SMT.Theory.Base.html#1984" class="Record">Signature</a> <a id="1911" href="SMT.Theory.Raw.Base.html#1504" class="InductiveConstructor">⋆</a>
  <a id="1915" href="SMT.Theory.Raw.Reflection.html#1875" class="Function">argTypes</a> <a id="1924" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>              <a id="1940" class="Symbol">.</a><a id="1941" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="1950" class="Symbol">=</a> <a id="1952" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="1957" href="SMT.Theory.Raw.Reflection.html#1875" class="Function">argTypes</a> <a id="1966" class="Symbol">(</a><a id="1967" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="1972" class="Symbol">_</a> <a id="1974" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1976" href="SMT.Theory.Raw.Reflection.html#1976" class="Bound">args</a><a id="1980" class="Symbol">)</a> <a id="1982" class="Symbol">.</a><a id="1983" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="1992" class="Symbol">=</a> <a id="1994" href="SMT.Theory.Raw.Base.html#1504" class="InductiveConstructor">⋆</a> <a id="1996" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1998" href="SMT.Theory.Raw.Reflection.html#1875" class="Function">argTypes</a> <a id="2007" href="SMT.Theory.Raw.Reflection.html#1976" class="Bound">args</a> <a id="2012" class="Symbol">.</a><a id="2013" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a>
  <a id="2024" href="SMT.Theory.Raw.Reflection.html#1875" class="CatchallClause Function">argTypes</a><a id="2032" class="CatchallClause"> </a><a id="2033" class="CatchallClause Symbol">(_</a><a id="2035" class="CatchallClause">      </a><a id="2041" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="2042" class="CatchallClause"> </a><a id="2043" href="SMT.Theory.Raw.Reflection.html#2043" class="CatchallClause Bound">args</a><a id="2047" class="CatchallClause Symbol">)</a><a id="2048" class="CatchallClause"> </a><a id="2049" class="CatchallClause Symbol">.</a><a id="2050" href="SMT.Theory.Base.html#2042" class="CatchallClause Field">ArgSorts</a> <a id="2059" class="Symbol">=</a>     <a id="2065" href="SMT.Theory.Raw.Reflection.html#1875" class="Function">argTypes</a> <a id="2074" href="SMT.Theory.Raw.Reflection.html#2043" class="Bound">args</a> <a id="2079" class="Symbol">.</a><a id="2080" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a>


<a id="reflectToRawVar"></a><a id="2091" href="SMT.Theory.Raw.Reflection.html#2091" class="Function">reflectToRawVar</a> <a id="2107" class="Symbol">:</a> <a id="2109" class="Symbol">(</a><a id="2110" href="SMT.Theory.Raw.Reflection.html#2110" class="Bound">Γ</a> <a id="2112" class="Symbol">:</a> <a id="2114" href="SMT.Theory.Raw.Base.html#3156" class="Function">RawCtxt</a><a id="2121" class="Symbol">)</a> <a id="2123" class="Symbol">(</a><a id="2124" href="SMT.Theory.Raw.Reflection.html#2124" class="Bound">n</a> <a id="2126" class="Symbol">:</a> <a id="2128" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2129" class="Symbol">)</a> <a id="2131" class="Symbol">→</a> <a id="2133" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="2136" class="Symbol">(</a><a id="2137" href="Data.Product.html#1806" class="Function">∃[</a> <a id="2140" href="SMT.Theory.Raw.Reflection.html#2140" class="Bound">σ</a> <a id="2142" href="Data.Product.html#1806" class="Function">]</a> <a id="2144" class="Symbol">(</a><a id="2145" href="SMT.Theory.Raw.Reflection.html#2110" class="Bound">Γ</a> <a id="2147" href="SMT.Theory.Raw.Base.html#3196" class="Function Operator">∋ᵣ</a> <a id="2150" href="SMT.Theory.Raw.Reflection.html#2140" class="Bound">σ</a><a id="2151" class="Symbol">))</a>
<a id="2154" href="SMT.Theory.Raw.Reflection.html#2091" class="Function">reflectToRawVar</a> <a id="2170" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>      <a id="2178" href="SMT.Theory.Raw.Reflection.html#2178" class="Bound">n</a>       <a id="2186" class="Symbol">=</a> <a id="2188" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="2201" class="String">&quot;Variable out of bounds&quot;</a>
<a id="2226" href="SMT.Theory.Raw.Reflection.html#2091" class="Function">reflectToRawVar</a> <a id="2242" class="Symbol">(</a><a id="2243" href="SMT.Theory.Raw.Reflection.html#2243" class="Bound">x</a> <a id="2245" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2247" href="SMT.Theory.Raw.Reflection.html#2247" class="Bound">Γ</a><a id="2248" class="Symbol">)</a> <a id="2250" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="2258" class="Symbol">=</a> <a id="2260" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2267" class="Symbol">(_</a> <a id="2270" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2272" href="Data.List.Relation.Unary.Any.html#1174" class="InductiveConstructor">here</a> <a id="2277" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="2281" class="Symbol">)</a>
<a id="2283" href="SMT.Theory.Raw.Reflection.html#2091" class="Function">reflectToRawVar</a> <a id="2299" class="Symbol">(</a><a id="2300" href="SMT.Theory.Raw.Reflection.html#2300" class="Bound">x</a> <a id="2302" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2304" href="SMT.Theory.Raw.Reflection.html#2304" class="Bound">Γ</a><a id="2305" class="Symbol">)</a> <a id="2307" class="Symbol">(</a><a id="2308" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="2312" href="SMT.Theory.Raw.Reflection.html#2312" class="Bound">n</a><a id="2313" class="Symbol">)</a> <a id="2315" class="Symbol">=</a> <a id="2317" class="Keyword">do</a>
  <a id="2322" href="SMT.Theory.Raw.Reflection.html#2322" class="Bound">σ</a> <a id="2324" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2326" href="SMT.Theory.Raw.Reflection.html#2326" class="Bound">p</a> <a id="2328" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="2330" href="SMT.Theory.Raw.Reflection.html#2091" class="Function">reflectToRawVar</a> <a id="2346" href="SMT.Theory.Raw.Reflection.html#2304" class="Bound">Γ</a> <a id="2348" href="SMT.Theory.Raw.Reflection.html#2312" class="Bound">n</a>
  <a id="2352" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2359" class="Symbol">(</a><a id="2360" href="SMT.Theory.Raw.Reflection.html#2322" class="Bound">σ</a> <a id="2362" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2364" href="Data.List.Relation.Unary.Any.html#1227" class="InductiveConstructor">there</a> <a id="2370" href="SMT.Theory.Raw.Reflection.html#2326" class="Bound">p</a><a id="2371" class="Symbol">)</a>

<a id="2374" class="Comment">-- | Keep track of which variables are allowed to be used by a script and which are not.</a>
<a id="2463" class="Comment">--   Non-dependent functions are translated to implication, but they still bring a variable</a>
<a id="2555" class="Comment">--   into scope in the reflected syntax. This will be marked &quot;not allowed&quot; for the script.</a>
<a id="AllowedVars"></a><a id="2646" href="SMT.Theory.Raw.Reflection.html#2646" class="Function">AllowedVars</a> <a id="2658" class="Symbol">=</a> <a id="2660" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="2665" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a>

<a id="2671" class="Comment">-- | If Γ ⊢ x, then |Γ| ⊢ strengthenVar x, where |Γ| is the restriction of Γ to</a>
<a id="2751" class="Comment">--   only the allowed variables. Fails if x is not an allowed variable.</a>
<a id="strengthenVar"></a><a id="2823" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="2837" class="Symbol">:</a> <a id="2839" class="Symbol">(</a><a id="2840" href="SMT.Theory.Raw.Reflection.html#2840" class="Bound">fv</a> <a id="2843" class="Symbol">:</a> <a id="2845" href="SMT.Theory.Raw.Reflection.html#2646" class="Function">AllowedVars</a><a id="2856" class="Symbol">)</a> <a id="2858" class="Symbol">(</a><a id="2859" href="SMT.Theory.Raw.Reflection.html#2859" class="Bound">n</a> <a id="2861" class="Symbol">:</a> <a id="2863" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2864" class="Symbol">)</a> <a id="2866" class="Symbol">→</a> <a id="2868" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="2871" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="2873" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="2887" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>            <a id="2901" class="Symbol">_</a>       <a id="2909" class="Symbol">=</a> <a id="2911" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="2924" class="String">&quot;Free variable in goal&quot;</a>
<a id="2948" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="2962" class="Symbol">(</a><a id="2963" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="2969" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="2971" class="Symbol">_)</a>   <a id="2976" class="Number">0</a>       <a id="2984" class="Symbol">=</a> <a id="2986" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2993" class="Number">0</a>
<a id="2995" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="3009" class="Symbol">(</a><a id="3010" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3016" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3018" class="Symbol">_)</a>   <a id="3023" class="Number">0</a>       <a id="3031" class="Symbol">=</a> <a id="3033" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="3046" class="String">&quot;Dependent quantification in term&quot;</a>
<a id="3081" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="3095" class="Symbol">(</a><a id="3096" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="3102" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3104" href="SMT.Theory.Raw.Reflection.html#3104" class="Bound">fvs</a><a id="3107" class="Symbol">)</a> <a id="3109" class="Symbol">(</a><a id="3110" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3114" href="SMT.Theory.Raw.Reflection.html#3114" class="Bound">n</a><a id="3115" class="Symbol">)</a> <a id="3117" class="Symbol">=</a> <a id="3119" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="3133" href="SMT.Theory.Raw.Reflection.html#3104" class="Bound">fvs</a> <a id="3137" href="SMT.Theory.Raw.Reflection.html#3114" class="Bound">n</a>
<a id="3139" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="3153" class="Symbol">(</a><a id="3154" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="3160" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3162" href="SMT.Theory.Raw.Reflection.html#3162" class="Bound">fvs</a><a id="3165" class="Symbol">)</a> <a id="3167" class="Symbol">(</a><a id="3168" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3172" href="SMT.Theory.Raw.Reflection.html#3172" class="Bound">n</a><a id="3173" class="Symbol">)</a> <a id="3175" class="Symbol">=</a> <a id="3177" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3181" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="3185" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="3199" href="SMT.Theory.Raw.Reflection.html#3162" class="Bound">fvs</a> <a id="3203" href="SMT.Theory.Raw.Reflection.html#3172" class="Bound">n</a>

<a id="3206" class="Comment">-- Placeholder name used as a function symbol of type TERM _ → ⋆ to wrap variables.</a>
<a id="rawVar"></a><a id="3290" href="SMT.Theory.Raw.Reflection.html#3290" class="Function">rawVar</a> <a id="3297" class="Symbol">:</a> <a id="3299" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="3301" href="SMT.Theory.Raw.Reflection.html#3290" class="Function">rawVar</a> <a id="3308" class="Symbol">=</a> <a id="3310" class="Symbol">_</a>

<a id="3313" class="Keyword">private</a>
  <a id="3323" class="Keyword">pattern</a> <a id="`fromNat"></a><a id="3331" href="SMT.Theory.Raw.Reflection.html#3331" class="InductiveConstructor">`fromNat</a> <a id="3340" class="Symbol">=</a> <a id="3342" class="Keyword">quote</a> <a id="3348" href="Agda.Builtin.FromNat.html#282" class="Field">Number.fromNat</a>
  <a id="3365" class="Keyword">pattern</a> <a id="`fromNeg"></a><a id="3373" href="SMT.Theory.Raw.Reflection.html#3373" class="InductiveConstructor">`fromNeg</a> <a id="3382" class="Symbol">=</a> <a id="3384" class="Keyword">quote</a> <a id="3390" href="Agda.Builtin.FromNeg.html#284" class="Field">Negative.fromNeg</a>

  <a id="3410" class="Keyword">pattern</a> <a id="`Σ"></a><a id="3418" href="SMT.Theory.Raw.Reflection.html#3418" class="InductiveConstructor">`Σ</a>  <a id="3422" href="SMT.Theory.Raw.Reflection.html#3463" class="Bound">a</a> <a id="3424" href="SMT.Theory.Raw.Reflection.html#3472" class="Bound">b</a> <a id="3426" class="Symbol">=</a> <a id="3428" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="3432" class="Symbol">(</a><a id="3433" class="Keyword">quote</a> <a id="3439" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="3440" class="Symbol">)</a>        <a id="3449" class="Symbol">(_</a> <a id="3452" class="InductiveConstructor Operator">∷</a> <a id="3454" class="Symbol">_</a> <a id="3456" class="InductiveConstructor Operator">∷</a> <a id="3458" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="3463" href="SMT.Theory.Raw.Reflection.html#3463" class="Bound">a</a> <a id="3465" class="InductiveConstructor Operator">∷</a> <a id="3467" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="3472" href="SMT.Theory.Raw.Reflection.html#3472" class="Bound">b</a> <a id="3474" class="InductiveConstructor Operator">∷</a> <a id="3476" class="InductiveConstructor">[]</a><a id="3478" class="Symbol">)</a>
  <a id="3482" class="Keyword">pattern</a> <a id="`Σˢ"></a><a id="3490" href="SMT.Theory.Raw.Reflection.html#3490" class="InductiveConstructor">`Σˢ</a> <a id="3494" href="SMT.Theory.Raw.Reflection.html#3535" class="Bound">a</a> <a id="3496" href="SMT.Theory.Raw.Reflection.html#3544" class="Bound">b</a> <a id="3498" class="Symbol">=</a> <a id="3500" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="3504" class="Symbol">(</a><a id="3505" class="Keyword">quote</a> <a id="3511" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="3519" class="Symbol">)</a> <a id="3521" class="Symbol">(_</a> <a id="3524" class="InductiveConstructor Operator">∷</a> <a id="3526" class="Symbol">_</a> <a id="3528" class="InductiveConstructor Operator">∷</a> <a id="3530" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="3535" href="SMT.Theory.Raw.Reflection.html#3535" class="Bound">a</a> <a id="3537" class="InductiveConstructor Operator">∷</a> <a id="3539" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="3544" href="SMT.Theory.Raw.Reflection.html#3544" class="Bound">b</a> <a id="3546" class="InductiveConstructor Operator">∷</a> <a id="3548" class="InductiveConstructor">[]</a><a id="3550" class="Symbol">)</a>
  <a id="3554" class="Keyword">pattern</a> <a id="`∃"></a><a id="3562" href="SMT.Theory.Raw.Reflection.html#3562" class="InductiveConstructor">`∃</a>  <a id="3566" href="SMT.Theory.Raw.Reflection.html#3607" class="Bound">a</a> <a id="3568" href="SMT.Theory.Raw.Reflection.html#3616" class="Bound">b</a> <a id="3570" class="Symbol">=</a> <a id="3572" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="3576" class="Symbol">(</a><a id="3577" class="Keyword">quote</a> <a id="3583" href="Data.Product.html#1369" class="Function">∃</a><a id="3584" class="Symbol">)</a>        <a id="3593" class="Symbol">(_</a> <a id="3596" class="InductiveConstructor Operator">∷</a> <a id="3598" class="Symbol">_</a> <a id="3600" class="InductiveConstructor Operator">∷</a> <a id="3602" href="Reflection.Argument.html#1126" class="InductiveConstructor">hArg</a> <a id="3607" href="SMT.Theory.Raw.Reflection.html#3607" class="Bound">a</a> <a id="3609" class="InductiveConstructor Operator">∷</a> <a id="3611" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="3616" href="SMT.Theory.Raw.Reflection.html#3616" class="Bound">b</a> <a id="3618" class="InductiveConstructor Operator">∷</a> <a id="3620" class="InductiveConstructor">[]</a><a id="3622" class="Symbol">)</a>
  <a id="3626" class="Keyword">pattern</a> <a id="`∃ˢ"></a><a id="3634" href="SMT.Theory.Raw.Reflection.html#3634" class="InductiveConstructor">`∃ˢ</a> <a id="3638" href="SMT.Theory.Raw.Reflection.html#3679" class="Bound">a</a> <a id="3640" href="SMT.Theory.Raw.Reflection.html#3688" class="Bound">b</a> <a id="3642" class="Symbol">=</a> <a id="3644" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="3648" class="Symbol">(</a><a id="3649" class="Keyword">quote</a> <a id="3655" href="Data.Product.html#1806" class="Function">∃-syntax</a><a id="3663" class="Symbol">)</a> <a id="3665" class="Symbol">(_</a> <a id="3668" class="InductiveConstructor Operator">∷</a> <a id="3670" class="Symbol">_</a> <a id="3672" class="InductiveConstructor Operator">∷</a> <a id="3674" href="Reflection.Argument.html#1126" class="InductiveConstructor">hArg</a> <a id="3679" href="SMT.Theory.Raw.Reflection.html#3679" class="Bound">a</a> <a id="3681" class="InductiveConstructor Operator">∷</a> <a id="3683" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="3688" href="SMT.Theory.Raw.Reflection.html#3688" class="Bound">b</a> <a id="3690" class="InductiveConstructor Operator">∷</a> <a id="3692" class="InductiveConstructor">[]</a><a id="3694" class="Symbol">)</a>

<a id="3697" class="Keyword">mutual</a>
  <a id="3706" class="Comment">-- |To avoid having to deal with overloaded literals in the different theories (the dictionaries</a>
  <a id="3805" class="Comment">--  are hard to deal with), we normalise any calls to fromNat and fromNeg.  To convince the</a>
  <a id="3899" class="Comment">--  termination checker that this is fine there&#39;s a fuel parameter limiting how many nested</a>
  <a id="3993" class="Comment">--  normalisations we are allowed to do. Overloading will not create any nested calls to fromNat</a>
  <a id="4092" class="Comment">--  or fromNeg so it&#39;s enough to provide 1 fuel for this.</a>
  <a id="4152" class="Comment">--  However we also use the fuel when eta-expanding the predicate in existentials, and since these</a>
  <a id="4253" class="Comment">--  can be arbitrarily nested we need a reasonable amount of fuel.</a>
  <a id="reflectToRawTerm"></a><a id="4322" href="SMT.Theory.Raw.Reflection.html#4322" class="Function">reflectToRawTerm</a> <a id="4339" class="Symbol">:</a> <a id="4341" class="Symbol">(</a><a id="4342" href="SMT.Theory.Raw.Reflection.html#4342" class="Bound">Γ</a> <a id="4344" class="Symbol">:</a> <a id="4346" href="SMT.Theory.Raw.Base.html#3156" class="Function">RawCtxt</a><a id="4353" class="Symbol">)</a> <a id="4355" class="Symbol">(</a><a id="4356" href="SMT.Theory.Raw.Reflection.html#4356" class="Bound">fv</a> <a id="4359" class="Symbol">:</a> <a id="4361" href="SMT.Theory.Raw.Reflection.html#2646" class="Function">AllowedVars</a><a id="4372" class="Symbol">)</a> <a id="4374" class="Symbol">→</a> <a id="4376" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="4381" class="Symbol">→</a> <a id="4383" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="4386" class="Symbol">(</a><a id="4387" href="SMT.Theory.Raw.Base.html#3233" class="Datatype">RawTerm</a> <a id="4395" href="SMT.Theory.Raw.Reflection.html#4342" class="Bound">Γ</a> <a id="4397" href="SMT.Theory.Raw.Base.html#1504" class="InductiveConstructor">⋆</a><a id="4398" class="Symbol">)</a>
  <a id="4402" href="SMT.Theory.Raw.Reflection.html#4322" class="Function">reflectToRawTerm</a> <a id="4419" class="Symbol">=</a> <a id="4421" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="4439" class="Number">1000</a>

  <a id="reflectToRawTerm′"></a><a id="4447" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="4465" class="Symbol">:</a> <a id="4467" class="Symbol">(</a><a id="4468" href="SMT.Theory.Raw.Reflection.html#4468" class="Bound">fuel</a> <a id="4473" class="Symbol">:</a> <a id="4475" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="4476" class="Symbol">)</a> <a id="4478" class="Symbol">(</a><a id="4479" href="SMT.Theory.Raw.Reflection.html#4479" class="Bound">Γ</a> <a id="4481" class="Symbol">:</a> <a id="4483" href="SMT.Theory.Raw.Base.html#3156" class="Function">RawCtxt</a><a id="4490" class="Symbol">)</a> <a id="4492" class="Symbol">(</a><a id="4493" href="SMT.Theory.Raw.Reflection.html#4493" class="Bound">fv</a> <a id="4496" class="Symbol">:</a> <a id="4498" href="SMT.Theory.Raw.Reflection.html#2646" class="Function">AllowedVars</a><a id="4509" class="Symbol">)</a> <a id="4511" class="Symbol">→</a> <a id="4513" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="4518" class="Symbol">→</a> <a id="4520" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="4523" class="Symbol">(</a><a id="4524" href="SMT.Theory.Raw.Base.html#3233" class="Datatype">RawTerm</a> <a id="4532" href="SMT.Theory.Raw.Reflection.html#4479" class="Bound">Γ</a> <a id="4534" href="SMT.Theory.Raw.Base.html#1504" class="InductiveConstructor">⋆</a><a id="4535" class="Symbol">)</a>
  <a id="4539" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="4557" href="SMT.Theory.Raw.Reflection.html#4557" class="Bound">fuel</a> <a id="4562" href="SMT.Theory.Raw.Reflection.html#4562" class="Bound">Γ</a> <a id="4564" href="SMT.Theory.Raw.Reflection.html#4564" class="Bound">fv</a> <a id="4567" class="Symbol">(</a><a id="4568" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="4572" href="SMT.Theory.Raw.Reflection.html#4572" class="Bound">x</a> <a id="4574" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4576" class="Symbol">)</a> <a id="4578" class="Symbol">=</a> <a id="4580" class="Keyword">do</a>
    <a id="4587" href="SMT.Theory.Raw.Reflection.html#4587" class="Bound">σ</a> <a id="4589" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="4591" href="SMT.Theory.Raw.Reflection.html#4591" class="Bound">y</a> <a id="4593" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4595" href="SMT.Theory.Raw.Reflection.html#2091" class="Function">reflectToRawVar</a> <a id="4611" href="SMT.Theory.Raw.Reflection.html#4562" class="Bound">Γ</a> <a id="4613" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="4617" href="SMT.Theory.Raw.Reflection.html#2823" class="Function">strengthenVar</a> <a id="4631" href="SMT.Theory.Raw.Reflection.html#4564" class="Bound">fv</a> <a id="4634" href="SMT.Theory.Raw.Reflection.html#4572" class="Bound">x</a>
    <a id="4640" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4647" class="Symbol">(</a><a id="4648" href="SMT.Theory.Raw.Base.html#3349" class="InductiveConstructor">`appᵣ</a> <a id="4654" class="Symbol">{</a><a id="4655" class="Argument">Σ</a> <a id="4657" class="Symbol">=</a> <a id="4659" class="Keyword">record</a><a id="4665" class="Symbol">{</a><a id="4666" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="4675" class="Symbol">=</a> <a id="4677" href="SMT.Theory.Raw.Reflection.html#4587" class="Bound">σ</a> <a id="4679" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4681" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4683" class="Symbol">}}</a> <a id="4686" class="Symbol">(</a><a id="4687" class="Keyword">quote</a> <a id="4693" href="SMT.Theory.Raw.Reflection.html#3290" class="Function">rawVar</a><a id="4699" class="Symbol">)</a> <a id="4701" class="Symbol">(</a><a id="4702" href="SMT.Theory.Raw.Base.html#3273" class="InductiveConstructor">`varᵣ</a> <a id="4708" href="SMT.Theory.Raw.Reflection.html#4591" class="Bound">y</a> <a id="4710" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4712" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="4714" class="Symbol">))</a>
  <a id="4719" href="SMT.Theory.Raw.Reflection.html#4447" class="CatchallClause Function">reflectToRawTerm′</a><a id="4736" class="CatchallClause"> </a><a id="4737" href="SMT.Theory.Raw.Reflection.html#4737" class="CatchallClause Bound">fuel</a><a id="4741" class="CatchallClause"> </a><a id="4742" href="SMT.Theory.Raw.Reflection.html#4742" class="CatchallClause Bound">Γ</a><a id="4743" class="CatchallClause"> </a><a id="4744" class="CatchallClause Symbol">_</a><a id="4745" class="CatchallClause">  </a><a id="4747" class="CatchallClause Symbol">(</a><a id="4748" href="Agda.Builtin.Reflection.html#4348" class="CatchallClause InductiveConstructor">var</a><a id="4751" class="CatchallClause"> </a><a id="4752" class="CatchallClause Symbol">_</a><a id="4753" class="CatchallClause"> </a><a id="4754" class="CatchallClause Symbol">_)</a>  <a id="4758" class="Symbol">=</a> <a id="4760" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="4773" class="String">&quot;Higher-order variable&quot;</a>
  <a id="4799" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="4817" href="SMT.Theory.Raw.Reflection.html#4817" class="Bound">fuel</a> <a id="4822" href="SMT.Theory.Raw.Reflection.html#4822" class="Bound">Γ</a> <a id="4824" class="Symbol">_</a>  <a id="4827" class="Symbol">(</a><a id="4828" href="Agda.Builtin.Reflection.html#4719" class="InductiveConstructor">lit</a> <a id="4832" href="SMT.Theory.Raw.Reflection.html#4832" class="Bound">l</a><a id="4833" class="Symbol">)</a>    <a id="4838" class="Symbol">=</a> <a id="4840" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4847" class="Symbol">(</a><a id="4848" href="SMT.Theory.Raw.Base.html#3311" class="InductiveConstructor">`litᵣ</a> <a id="4854" href="SMT.Theory.Raw.Reflection.html#4832" class="Bound">l</a><a id="4855" class="Symbol">)</a>
  <a id="4859" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="4877" class="Symbol">(</a><a id="4878" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4882" href="SMT.Theory.Raw.Reflection.html#4882" class="Bound">fuel</a><a id="4886" class="Symbol">)</a> <a id="4888" href="SMT.Theory.Raw.Reflection.html#4888" class="Bound">Γ</a> <a id="4890" href="SMT.Theory.Raw.Reflection.html#4890" class="Bound">fv</a> <a id="4893" href="SMT.Theory.Raw.Reflection.html#4893" class="Bound">t</a><a id="4894" class="Symbol">@(</a><a id="4896" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="4900" href="SMT.Theory.Raw.Reflection.html#3331" class="InductiveConstructor">`fromNat</a> <a id="4909" class="Symbol">_)</a> <a id="4912" class="Symbol">=</a> <a id="4914" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="4932" href="SMT.Theory.Raw.Reflection.html#4882" class="Bound">fuel</a> <a id="4937" href="SMT.Theory.Raw.Reflection.html#4888" class="Bound">Γ</a> <a id="4939" href="SMT.Theory.Raw.Reflection.html#4890" class="Bound">fv</a> <a id="4942" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="4946" href="Agda.Builtin.Reflection.html#7855" class="Postulate">normalise</a> <a id="4956" href="SMT.Theory.Raw.Reflection.html#4893" class="Bound">t</a>
  <a id="4960" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="4978" class="Symbol">(</a><a id="4979" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4983" href="SMT.Theory.Raw.Reflection.html#4983" class="Bound">fuel</a><a id="4987" class="Symbol">)</a> <a id="4989" href="SMT.Theory.Raw.Reflection.html#4989" class="Bound">Γ</a> <a id="4991" href="SMT.Theory.Raw.Reflection.html#4991" class="Bound">fv</a> <a id="4994" href="SMT.Theory.Raw.Reflection.html#4994" class="Bound">t</a><a id="4995" class="Symbol">@(</a><a id="4997" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="5001" href="SMT.Theory.Raw.Reflection.html#3373" class="InductiveConstructor">`fromNeg</a> <a id="5010" class="Symbol">_)</a> <a id="5013" class="Symbol">=</a> <a id="5015" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5033" href="SMT.Theory.Raw.Reflection.html#4983" class="Bound">fuel</a> <a id="5038" href="SMT.Theory.Raw.Reflection.html#4989" class="Bound">Γ</a> <a id="5040" href="SMT.Theory.Raw.Reflection.html#4991" class="Bound">fv</a> <a id="5043" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="5047" href="Agda.Builtin.Reflection.html#7855" class="Postulate">normalise</a> <a id="5057" href="SMT.Theory.Raw.Reflection.html#4994" class="Bound">t</a>
  <a id="5061" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5079" class="Symbol">(</a><a id="5080" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5084" href="SMT.Theory.Raw.Reflection.html#5084" class="Bound">fuel</a><a id="5088" class="Symbol">)</a> <a id="5090" href="SMT.Theory.Raw.Reflection.html#5090" class="Bound">Γ</a> <a id="5092" href="SMT.Theory.Raw.Reflection.html#5092" class="Bound">fv</a> <a id="5095" class="Symbol">(</a><a id="5096" href="SMT.Theory.Raw.Reflection.html#3418" class="InductiveConstructor">`Σ</a>  <a id="5100" href="SMT.Theory.Raw.Reflection.html#5100" class="Bound">a</a> <a id="5102" href="SMT.Theory.Raw.Reflection.html#5102" class="Bound">b</a><a id="5103" class="Symbol">)</a> <a id="5105" class="Symbol">=</a> <a id="5107" href="SMT.Theory.Raw.Reflection.html#6128" class="Function">reflectExist</a> <a id="5120" href="SMT.Theory.Raw.Reflection.html#5084" class="Bound">fuel</a> <a id="5125" href="SMT.Theory.Raw.Reflection.html#5090" class="Bound">Γ</a> <a id="5127" href="SMT.Theory.Raw.Reflection.html#5092" class="Bound">fv</a> <a id="5130" href="SMT.Theory.Raw.Reflection.html#5100" class="Bound">a</a> <a id="5132" href="SMT.Theory.Raw.Reflection.html#5102" class="Bound">b</a>
  <a id="5136" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5154" class="Symbol">(</a><a id="5155" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5159" href="SMT.Theory.Raw.Reflection.html#5159" class="Bound">fuel</a><a id="5163" class="Symbol">)</a> <a id="5165" href="SMT.Theory.Raw.Reflection.html#5165" class="Bound">Γ</a> <a id="5167" href="SMT.Theory.Raw.Reflection.html#5167" class="Bound">fv</a> <a id="5170" class="Symbol">(</a><a id="5171" href="SMT.Theory.Raw.Reflection.html#3490" class="InductiveConstructor">`Σˢ</a> <a id="5175" href="SMT.Theory.Raw.Reflection.html#5175" class="Bound">a</a> <a id="5177" href="SMT.Theory.Raw.Reflection.html#5177" class="Bound">b</a><a id="5178" class="Symbol">)</a> <a id="5180" class="Symbol">=</a> <a id="5182" href="SMT.Theory.Raw.Reflection.html#6128" class="Function">reflectExist</a> <a id="5195" href="SMT.Theory.Raw.Reflection.html#5159" class="Bound">fuel</a> <a id="5200" href="SMT.Theory.Raw.Reflection.html#5165" class="Bound">Γ</a> <a id="5202" href="SMT.Theory.Raw.Reflection.html#5167" class="Bound">fv</a> <a id="5205" href="SMT.Theory.Raw.Reflection.html#5175" class="Bound">a</a> <a id="5207" href="SMT.Theory.Raw.Reflection.html#5177" class="Bound">b</a>
  <a id="5211" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5229" class="Symbol">(</a><a id="5230" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5234" href="SMT.Theory.Raw.Reflection.html#5234" class="Bound">fuel</a><a id="5238" class="Symbol">)</a> <a id="5240" href="SMT.Theory.Raw.Reflection.html#5240" class="Bound">Γ</a> <a id="5242" href="SMT.Theory.Raw.Reflection.html#5242" class="Bound">fv</a> <a id="5245" class="Symbol">(</a><a id="5246" href="SMT.Theory.Raw.Reflection.html#3562" class="InductiveConstructor">`∃</a>  <a id="5250" href="SMT.Theory.Raw.Reflection.html#5250" class="Bound">a</a> <a id="5252" href="SMT.Theory.Raw.Reflection.html#5252" class="Bound">b</a><a id="5253" class="Symbol">)</a> <a id="5255" class="Symbol">=</a> <a id="5257" href="SMT.Theory.Raw.Reflection.html#6128" class="Function">reflectExist</a> <a id="5270" href="SMT.Theory.Raw.Reflection.html#5234" class="Bound">fuel</a> <a id="5275" href="SMT.Theory.Raw.Reflection.html#5240" class="Bound">Γ</a> <a id="5277" href="SMT.Theory.Raw.Reflection.html#5242" class="Bound">fv</a> <a id="5280" href="SMT.Theory.Raw.Reflection.html#5250" class="Bound">a</a> <a id="5282" href="SMT.Theory.Raw.Reflection.html#5252" class="Bound">b</a>
  <a id="5286" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5304" class="Symbol">(</a><a id="5305" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="5309" href="SMT.Theory.Raw.Reflection.html#5309" class="Bound">fuel</a><a id="5313" class="Symbol">)</a> <a id="5315" href="SMT.Theory.Raw.Reflection.html#5315" class="Bound">Γ</a> <a id="5317" href="SMT.Theory.Raw.Reflection.html#5317" class="Bound">fv</a> <a id="5320" class="Symbol">(</a><a id="5321" href="SMT.Theory.Raw.Reflection.html#3634" class="InductiveConstructor">`∃ˢ</a> <a id="5325" href="SMT.Theory.Raw.Reflection.html#5325" class="Bound">a</a> <a id="5327" href="SMT.Theory.Raw.Reflection.html#5327" class="Bound">b</a><a id="5328" class="Symbol">)</a> <a id="5330" class="Symbol">=</a> <a id="5332" href="SMT.Theory.Raw.Reflection.html#6128" class="Function">reflectExist</a> <a id="5345" href="SMT.Theory.Raw.Reflection.html#5309" class="Bound">fuel</a> <a id="5350" href="SMT.Theory.Raw.Reflection.html#5315" class="Bound">Γ</a> <a id="5352" href="SMT.Theory.Raw.Reflection.html#5317" class="Bound">fv</a> <a id="5355" href="SMT.Theory.Raw.Reflection.html#5325" class="Bound">a</a> <a id="5357" href="SMT.Theory.Raw.Reflection.html#5327" class="Bound">b</a>
  <a id="5361" href="SMT.Theory.Raw.Reflection.html#4447" class="CatchallClause Function">reflectToRawTerm′</a><a id="5378" class="CatchallClause"> </a><a id="5379" href="SMT.Theory.Raw.Reflection.html#5379" class="CatchallClause Bound">fuel</a><a id="5383" class="CatchallClause"> </a><a id="5384" href="SMT.Theory.Raw.Reflection.html#5384" class="CatchallClause Bound">Γ</a><a id="5385" class="CatchallClause"> </a><a id="5386" href="SMT.Theory.Raw.Reflection.html#5386" class="CatchallClause Bound">fv</a><a id="5388" class="CatchallClause"> </a><a id="5389" class="CatchallClause Symbol">(</a><a id="5390" href="Agda.Builtin.Reflection.html#4461" class="CatchallClause InductiveConstructor">def</a><a id="5393" class="CatchallClause"> </a><a id="5394" href="SMT.Theory.Raw.Reflection.html#5394" class="CatchallClause Bound">f</a><a id="5395" class="CatchallClause"> </a><a id="5396" href="SMT.Theory.Raw.Reflection.html#5396" class="CatchallClause Bound">ts</a><a id="5398" class="CatchallClause Symbol">)</a> <a id="5400" class="Symbol">=</a> <a id="5402" href="SMT.Theory.Raw.Base.html#3349" class="InductiveConstructor">`appᵣ</a> <a id="5408" class="Symbol">{</a><a id="5409" class="Argument">Σ</a> <a id="5411" class="Symbol">=</a> <a id="5413" href="SMT.Theory.Raw.Reflection.html#1875" class="Function">argTypes</a> <a id="5422" href="SMT.Theory.Raw.Reflection.html#5396" class="Bound">ts</a><a id="5424" class="Symbol">}</a> <a id="5426" href="SMT.Theory.Raw.Reflection.html#5394" class="Bound">f</a> <a id="5428" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="5432" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="5449" href="SMT.Theory.Raw.Reflection.html#5379" class="Bound">fuel</a> <a id="5454" href="SMT.Theory.Raw.Reflection.html#5384" class="Bound">Γ</a> <a id="5456" href="SMT.Theory.Raw.Reflection.html#5386" class="Bound">fv</a> <a id="5459" href="SMT.Theory.Raw.Reflection.html#5396" class="Bound">ts</a>
  <a id="5464" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5482" href="SMT.Theory.Raw.Reflection.html#5482" class="Bound">fuel</a> <a id="5487" href="SMT.Theory.Raw.Reflection.html#5487" class="Bound">Γ</a> <a id="5489" href="SMT.Theory.Raw.Reflection.html#5489" class="Bound">fv</a> <a id="5492" class="Symbol">(</a><a id="5493" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="5497" href="SMT.Theory.Raw.Reflection.html#5497" class="Bound">c</a> <a id="5499" href="SMT.Theory.Raw.Reflection.html#5499" class="Bound">ts</a><a id="5501" class="Symbol">)</a> <a id="5503" class="Symbol">=</a> <a id="5505" href="SMT.Theory.Raw.Base.html#3349" class="InductiveConstructor">`appᵣ</a> <a id="5511" class="Symbol">{</a><a id="5512" class="Argument">Σ</a> <a id="5514" class="Symbol">=</a> <a id="5516" href="SMT.Theory.Raw.Reflection.html#1875" class="Function">argTypes</a> <a id="5525" href="SMT.Theory.Raw.Reflection.html#5499" class="Bound">ts</a><a id="5527" class="Symbol">}</a> <a id="5529" href="SMT.Theory.Raw.Reflection.html#5497" class="Bound">c</a> <a id="5531" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="5535" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="5552" href="SMT.Theory.Raw.Reflection.html#5482" class="Bound">fuel</a> <a id="5557" href="SMT.Theory.Raw.Reflection.html#5487" class="Bound">Γ</a> <a id="5559" href="SMT.Theory.Raw.Reflection.html#5489" class="Bound">fv</a> <a id="5562" href="SMT.Theory.Raw.Reflection.html#5499" class="Bound">ts</a>
  <a id="5567" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5585" href="SMT.Theory.Raw.Reflection.html#5585" class="Bound">fuel</a> <a id="5590" href="SMT.Theory.Raw.Reflection.html#5590" class="Bound">Γ</a> <a id="5592" href="SMT.Theory.Raw.Reflection.html#5592" class="Bound">fv</a> <a id="5595" class="Symbol">(</a><a id="5596" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="5599" href="SMT.Theory.Raw.Reflection.html#5599" class="Bound">dom</a><a id="5602" class="Symbol">@(</a><a id="5604" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="5608" class="Symbol">_</a> <a id="5610" href="SMT.Theory.Raw.Reflection.html#5610" class="Bound">a</a><a id="5611" class="Symbol">)</a> <a id="5613" class="Symbol">(</a><a id="5614" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="5618" href="SMT.Theory.Raw.Reflection.html#5618" class="Bound">x</a> <a id="5620" href="SMT.Theory.Raw.Reflection.html#5620" class="Bound">b</a><a id="5621" class="Symbol">))</a> <a id="5624" class="Symbol">=</a> <a id="5626" class="Keyword">do</a>
    <a id="5633" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="5638" class="Number">0</a> <a id="5640" href="Reflection.DeBruijn.html#3864" class="Function Operator">∈FV</a> <a id="5644" href="SMT.Theory.Raw.Reflection.html#5620" class="Bound">b</a> <a id="5646" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="5649" class="Symbol">λ</a> <a id="5651" class="Keyword">where</a>
      <a id="5663" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="5669" class="Symbol">→</a>
        <a id="5679" href="SMT.Theory.Raw.Base.html#3387" class="InductiveConstructor">`forallᵣ</a> <a id="5688" href="SMT.Theory.Raw.Reflection.html#5618" class="Bound">x</a> <a id="5690" class="Symbol">(</a><a id="5691" href="SMT.Theory.Raw.Base.html#1521" class="InductiveConstructor">TERM</a> <a id="5696" href="SMT.Theory.Raw.Reflection.html#5610" class="Bound">a</a><a id="5697" class="Symbol">)</a> <a id="5699" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="5703" href="Agda.Builtin.Reflection.html#8183" class="Postulate">extendContext</a> <a id="5717" href="SMT.Theory.Raw.Reflection.html#5599" class="Bound">dom</a> <a id="5721" class="Symbol">(</a><a id="5722" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5740" href="SMT.Theory.Raw.Reflection.html#5585" class="Bound">fuel</a> <a id="5745" class="Symbol">(</a><a id="5746" href="SMT.Theory.Raw.Base.html#1521" class="InductiveConstructor">TERM</a> <a id="5751" href="SMT.Theory.Raw.Reflection.html#5610" class="Bound">a</a> <a id="5753" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5755" href="SMT.Theory.Raw.Reflection.html#5590" class="Bound">Γ</a><a id="5756" class="Symbol">)</a> <a id="5758" class="Symbol">(</a><a id="5759" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="5764" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5766" href="SMT.Theory.Raw.Reflection.html#5592" class="Bound">fv</a><a id="5768" class="Symbol">)</a> <a id="5770" href="SMT.Theory.Raw.Reflection.html#5620" class="Bound">b</a><a id="5771" class="Symbol">)</a>
      <a id="5779" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5785" class="Symbol">→</a> <a id="5787" class="Keyword">do</a>
        <a id="5798" href="SMT.Theory.Raw.Reflection.html#5798" class="Bound">a</a> <a id="5800" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5802" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5820" href="SMT.Theory.Raw.Reflection.html#5585" class="Bound">fuel</a> <a id="5825" href="SMT.Theory.Raw.Reflection.html#5590" class="Bound">Γ</a> <a id="5827" href="SMT.Theory.Raw.Reflection.html#5592" class="Bound">fv</a> <a id="5830" href="SMT.Theory.Raw.Reflection.html#5610" class="Bound">a</a>
        <a id="5840" href="SMT.Theory.Raw.Reflection.html#5840" class="Bound">b</a> <a id="5842" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5844" href="Agda.Builtin.Reflection.html#8183" class="Postulate">extendContext</a> <a id="5858" href="SMT.Theory.Raw.Reflection.html#5599" class="Bound">dom</a> <a id="5862" class="Symbol">(</a><a id="5863" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="5881" href="SMT.Theory.Raw.Reflection.html#5585" class="Bound">fuel</a> <a id="5886" href="SMT.Theory.Raw.Reflection.html#5590" class="Bound">Γ</a> <a id="5888" class="Symbol">(</a><a id="5889" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="5895" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5897" href="SMT.Theory.Raw.Reflection.html#5592" class="Bound">fv</a><a id="5899" class="Symbol">)</a> <a id="5901" href="SMT.Theory.Raw.Reflection.html#5620" class="Bound">b</a><a id="5902" class="Symbol">)</a>
        <a id="5912" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5919" class="Symbol">(</a><a id="5920" href="SMT.Theory.Raw.Base.html#3349" class="InductiveConstructor">`appᵣ</a> <a id="5926" class="Symbol">{</a><a id="5927" class="Argument">Σ</a> <a id="5929" class="Symbol">=</a> <a id="5931" class="Keyword">record</a> <a id="5938" class="Symbol">{</a><a id="5939" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="5948" class="Symbol">=</a> <a id="5950" href="SMT.Theory.Raw.Base.html#1504" class="InductiveConstructor">⋆</a> <a id="5952" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5954" href="SMT.Theory.Raw.Base.html#1504" class="InductiveConstructor">⋆</a> <a id="5956" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5958" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="5960" class="Symbol">}}</a> <a id="5963" class="Symbol">(</a><a id="5964" class="Keyword">quote</a> <a id="5970" href="Function.Core.html#646" class="Function">Morphism</a><a id="5978" class="Symbol">)</a> <a id="5980" class="Symbol">(</a><a id="5981" href="SMT.Theory.Raw.Reflection.html#5798" class="Bound">a</a> <a id="5983" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="5985" href="SMT.Theory.Raw.Reflection.html#5840" class="Bound">b</a> <a id="5987" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="5989" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="5991" class="Symbol">))</a>
  <a id="5996" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="6014" href="SMT.Theory.Raw.Reflection.html#6014" class="Bound">fuel</a> <a id="6019" href="SMT.Theory.Raw.Reflection.html#6019" class="Bound">Γ</a> <a id="6021" href="SMT.Theory.Raw.Reflection.html#6021" class="Bound">fv</a> <a id="6024" class="Symbol">(</a><a id="6025" href="Agda.Builtin.Reflection.html#4754" class="InductiveConstructor">meta</a> <a id="6030" href="SMT.Theory.Raw.Reflection.html#6030" class="Bound">x</a> <a id="6032" class="Symbol">_)</a> <a id="6035" class="Symbol">=</a> <a id="6037" href="Agda.Builtin.Reflection.html#8569" class="Postulate">blockOnMeta</a> <a id="6049" href="SMT.Theory.Raw.Reflection.html#6030" class="Bound">x</a>
  <a id="6053" href="SMT.Theory.Raw.Reflection.html#4447" class="CatchallClause Function">reflectToRawTerm′</a><a id="6070" class="CatchallClause"> </a><a id="6071" href="SMT.Theory.Raw.Reflection.html#6071" class="CatchallClause Bound">fuel</a><a id="6075" class="CatchallClause"> </a><a id="6076" href="SMT.Theory.Raw.Reflection.html#6076" class="CatchallClause Bound">Γ</a><a id="6077" class="CatchallClause"> </a><a id="6078" href="SMT.Theory.Raw.Reflection.html#6078" class="CatchallClause Bound">fv</a><a id="6080" class="CatchallClause"> </a><a id="6081" href="SMT.Theory.Raw.Reflection.html#6081" class="CatchallClause Bound">t</a> <a id="6083" class="Symbol">=</a> <a id="6085" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="6098" class="String">&quot;reflectToRawTerm′ failed&quot;</a>

  <a id="reflectExist"></a><a id="6128" href="SMT.Theory.Raw.Reflection.html#6128" class="Function">reflectExist</a> <a id="6141" class="Symbol">:</a> <a id="6143" class="Symbol">(</a><a id="6144" href="SMT.Theory.Raw.Reflection.html#6144" class="Bound">fuel</a> <a id="6149" class="Symbol">:</a> <a id="6151" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6152" class="Symbol">)</a> <a id="6154" class="Symbol">(</a><a id="6155" href="SMT.Theory.Raw.Reflection.html#6155" class="Bound">Γ</a> <a id="6157" class="Symbol">:</a> <a id="6159" href="SMT.Theory.Raw.Base.html#3156" class="Function">RawCtxt</a><a id="6166" class="Symbol">)</a> <a id="6168" class="Symbol">(</a><a id="6169" href="SMT.Theory.Raw.Reflection.html#6169" class="Bound">fv</a> <a id="6172" class="Symbol">:</a> <a id="6174" href="SMT.Theory.Raw.Reflection.html#2646" class="Function">AllowedVars</a><a id="6185" class="Symbol">)</a> <a id="6187" class="Symbol">→</a> <a id="6189" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="6194" class="Symbol">→</a> <a id="6196" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="6201" class="Symbol">→</a> <a id="6203" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="6206" class="Symbol">(</a><a id="6207" href="SMT.Theory.Raw.Base.html#3233" class="Datatype">RawTerm</a> <a id="6215" href="SMT.Theory.Raw.Reflection.html#6155" class="Bound">Γ</a> <a id="6217" href="SMT.Theory.Raw.Base.html#1504" class="InductiveConstructor">⋆</a><a id="6218" class="Symbol">)</a>
  <a id="6222" href="SMT.Theory.Raw.Reflection.html#6128" class="Function">reflectExist</a> <a id="6235" href="SMT.Theory.Raw.Reflection.html#6235" class="Bound">fuel</a> <a id="6240" href="SMT.Theory.Raw.Reflection.html#6240" class="Bound">Γ</a> <a id="6242" href="SMT.Theory.Raw.Reflection.html#6242" class="Bound">fv</a> <a id="6245" href="SMT.Theory.Raw.Reflection.html#6245" class="Bound">a</a> <a id="6247" href="SMT.Theory.Raw.Reflection.html#6247" class="Bound">b</a> <a id="6249" class="Symbol">=</a> <a id="6251" class="Keyword">do</a>
    <a id="6258" href="Agda.Builtin.Reflection.html#4518" class="InductiveConstructor">lam</a> <a id="6262" class="Symbol">_</a> <a id="6264" class="Symbol">(</a><a id="6265" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="6269" href="SMT.Theory.Raw.Reflection.html#6269" class="Bound">x</a> <a id="6271" href="SMT.Theory.Raw.Reflection.html#6271" class="Bound">b</a><a id="6272" class="Symbol">)</a> <a id="6274" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="6276" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6283" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="6285" href="Reflection.DeBruijn.html#1949" class="Function">η-expand</a> <a id="6294" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a> <a id="6302" href="SMT.Theory.Raw.Reflection.html#6247" class="Bound">b</a>
      <a id="6310" class="Keyword">where</a> <a id="6316" class="CatchallClause Symbol">_</a><a id="6317" class="CatchallClause"> </a><a id="6318" class="CatchallClause Symbol">→</a><a id="6319" class="CatchallClause"> </a><a id="6320" href="Reflection.TypeChecking.Format.html#2592" class="CatchallClause Function">typeErrorFmt</a><a id="6332" class="CatchallClause"> </a><a id="6333" class="CatchallClause String">&quot;reflectedToRawTerm′ failed to η-expand existential predicate&quot;</a>
    <a id="6400" href="SMT.Theory.Raw.Base.html#3428" class="InductiveConstructor">`existsᵣ</a> <a id="6409" href="SMT.Theory.Raw.Reflection.html#6269" class="Bound">x</a> <a id="6411" class="Symbol">(</a><a id="6412" href="SMT.Theory.Raw.Base.html#1521" class="InductiveConstructor">TERM</a> <a id="6417" href="SMT.Theory.Raw.Reflection.html#6245" class="Bound">a</a><a id="6418" class="Symbol">)</a> <a id="6420" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="6424" href="Agda.Builtin.Reflection.html#8183" class="Postulate">extendContext</a> <a id="6438" class="Symbol">(</a><a id="6439" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="6444" href="SMT.Theory.Raw.Reflection.html#6245" class="Bound">a</a><a id="6445" class="Symbol">)</a> <a id="6447" class="Symbol">(</a><a id="6448" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="6466" href="SMT.Theory.Raw.Reflection.html#6235" class="Bound">fuel</a> <a id="6471" class="Symbol">(</a><a id="6472" href="SMT.Theory.Raw.Base.html#1521" class="InductiveConstructor">TERM</a> <a id="6477" href="SMT.Theory.Raw.Reflection.html#6245" class="Bound">a</a> <a id="6479" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6481" href="SMT.Theory.Raw.Reflection.html#6240" class="Bound">Γ</a><a id="6482" class="Symbol">)</a> <a id="6484" class="Symbol">(</a><a id="6485" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="6490" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6492" href="SMT.Theory.Raw.Reflection.html#6242" class="Bound">fv</a><a id="6494" class="Symbol">)</a> <a id="6496" href="SMT.Theory.Raw.Reflection.html#6271" class="Bound">b</a><a id="6497" class="Symbol">)</a>

  <a id="reflectToRawArgs"></a><a id="6502" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6519" class="Symbol">:</a> <a id="6521" class="Symbol">∀</a> <a id="6523" class="Symbol">(</a><a id="6524" href="SMT.Theory.Raw.Reflection.html#6524" class="Bound">fuel</a> <a id="6529" class="Symbol">:</a> <a id="6531" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6532" class="Symbol">)</a> <a id="6534" href="SMT.Theory.Raw.Reflection.html#6534" class="Bound">Γ</a> <a id="6536" class="Symbol">(</a><a id="6537" href="SMT.Theory.Raw.Reflection.html#6537" class="Bound">fv</a> <a id="6540" class="Symbol">:</a> <a id="6542" href="SMT.Theory.Raw.Reflection.html#2646" class="Function">AllowedVars</a><a id="6553" class="Symbol">)</a> <a id="6555" class="Symbol">(</a><a id="6556" href="SMT.Theory.Raw.Reflection.html#6556" class="Bound">ts</a> <a id="6559" class="Symbol">:</a> <a id="6561" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="6566" class="Symbol">(</a><a id="6567" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="6571" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="6575" class="Symbol">))</a> <a id="6578" class="Symbol">→</a> <a id="6580" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="6583" class="Symbol">(</a><a id="6584" href="SMT.Theory.Raw.Base.html#3507" class="Function">RawArgs</a> <a id="6592" href="SMT.Theory.Raw.Reflection.html#6534" class="Bound">Γ</a> <a id="6594" class="Symbol">(</a><a id="6595" href="SMT.Theory.Base.html#2042" class="Field">ArgSorts</a> <a id="6604" class="Symbol">(</a><a id="6605" href="SMT.Theory.Raw.Reflection.html#1875" class="Function">argTypes</a> <a id="6614" href="SMT.Theory.Raw.Reflection.html#6556" class="Bound">ts</a><a id="6616" class="Symbol">)))</a>
  <a id="6622" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6639" href="SMT.Theory.Raw.Reflection.html#6639" class="Bound">fuel</a> <a id="6644" href="SMT.Theory.Raw.Reflection.html#6644" class="Bound">Γ</a> <a id="6646" href="SMT.Theory.Raw.Reflection.html#6646" class="Bound">fv</a> <a id="6649" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="6652" class="Symbol">=</a> <a id="6654" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="6661" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a>
  <a id="6666" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6683" href="SMT.Theory.Raw.Reflection.html#6683" class="Bound">fuel</a> <a id="6688" href="SMT.Theory.Raw.Reflection.html#6688" class="Bound">Γ</a> <a id="6690" href="SMT.Theory.Raw.Reflection.html#6690" class="Bound">fv</a> <a id="6693" class="Symbol">(</a><a id="6694" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="6699" href="SMT.Theory.Raw.Reflection.html#6699" class="Bound">t</a> <a id="6701" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6703" href="SMT.Theory.Raw.Reflection.html#6703" class="Bound">ts</a><a id="6705" class="Symbol">)</a> <a id="6707" class="Symbol">=</a> <a id="6709" class="Symbol">⦇</a> <a id="6711" href="SMT.Theory.Raw.Reflection.html#4447" class="Function">reflectToRawTerm′</a> <a id="6729" href="SMT.Theory.Raw.Reflection.html#6683" class="Bound">fuel</a> <a id="6734" href="SMT.Theory.Raw.Reflection.html#6688" class="Bound">Γ</a> <a id="6736" href="SMT.Theory.Raw.Reflection.html#6690" class="Bound">fv</a> <a id="6739" href="SMT.Theory.Raw.Reflection.html#6699" class="Bound">t</a> <a id="6741" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="6743" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6760" href="SMT.Theory.Raw.Reflection.html#6683" class="Bound">fuel</a> <a id="6765" href="SMT.Theory.Raw.Reflection.html#6688" class="Bound">Γ</a> <a id="6767" href="SMT.Theory.Raw.Reflection.html#6690" class="Bound">fv</a> <a id="6770" href="SMT.Theory.Raw.Reflection.html#6703" class="Bound">ts</a> <a id="6773" class="Symbol">⦈</a>
  <a id="6777" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6794" href="SMT.Theory.Raw.Reflection.html#6794" class="Bound">fuel</a> <a id="6799" href="SMT.Theory.Raw.Reflection.html#6799" class="Bound">Γ</a> <a id="6801" href="SMT.Theory.Raw.Reflection.html#6801" class="Bound">fv</a> <a id="6804" class="Symbol">(</a><a id="6805" href="Reflection.Argument.html#1126" class="InductiveConstructor">hArg</a> <a id="6810" class="Symbol">_</a> <a id="6812" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6814" href="SMT.Theory.Raw.Reflection.html#6814" class="Bound">ts</a><a id="6816" class="Symbol">)</a> <a id="6818" class="Symbol">=</a> <a id="6820" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6837" href="SMT.Theory.Raw.Reflection.html#6794" class="Bound">fuel</a> <a id="6842" href="SMT.Theory.Raw.Reflection.html#6799" class="Bound">Γ</a> <a id="6844" href="SMT.Theory.Raw.Reflection.html#6801" class="Bound">fv</a> <a id="6847" href="SMT.Theory.Raw.Reflection.html#6814" class="Bound">ts</a>
  <a id="6852" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6869" href="SMT.Theory.Raw.Reflection.html#6869" class="Bound">fuel</a> <a id="6874" href="SMT.Theory.Raw.Reflection.html#6874" class="Bound">Γ</a> <a id="6876" href="SMT.Theory.Raw.Reflection.html#6876" class="Bound">fv</a> <a id="6879" class="Symbol">(</a><a id="6880" href="Reflection.Argument.html#1181" class="InductiveConstructor">iArg</a> <a id="6885" class="Symbol">_</a> <a id="6887" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6889" href="SMT.Theory.Raw.Reflection.html#6889" class="Bound">ts</a><a id="6891" class="Symbol">)</a> <a id="6893" class="Symbol">=</a> <a id="6895" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6912" href="SMT.Theory.Raw.Reflection.html#6869" class="Bound">fuel</a> <a id="6917" href="SMT.Theory.Raw.Reflection.html#6874" class="Bound">Γ</a> <a id="6919" href="SMT.Theory.Raw.Reflection.html#6876" class="Bound">fv</a> <a id="6922" href="SMT.Theory.Raw.Reflection.html#6889" class="Bound">ts</a>
  <a id="6927" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="6944" href="SMT.Theory.Raw.Reflection.html#6944" class="Bound">fuel</a> <a id="6949" href="SMT.Theory.Raw.Reflection.html#6949" class="Bound">Γ</a> <a id="6951" href="SMT.Theory.Raw.Reflection.html#6951" class="Bound">fv</a> <a id="6954" class="Symbol">(</a><a id="6955" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="6959" class="Symbol">(</a><a id="6960" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="6969" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a>   <a id="6979" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="6989" class="Symbol">)</a> <a id="6991" class="Symbol">_</a> <a id="6993" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6995" href="SMT.Theory.Raw.Reflection.html#6995" class="Bound">ts</a><a id="6997" class="Symbol">)</a> <a id="6999" class="Symbol">=</a> <a id="7001" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="7018" href="SMT.Theory.Raw.Reflection.html#6944" class="Bound">fuel</a> <a id="7023" href="SMT.Theory.Raw.Reflection.html#6949" class="Bound">Γ</a> <a id="7025" href="SMT.Theory.Raw.Reflection.html#6951" class="Bound">fv</a> <a id="7028" href="SMT.Theory.Raw.Reflection.html#6995" class="Bound">ts</a>
  <a id="7033" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="7050" href="SMT.Theory.Raw.Reflection.html#7050" class="Bound">fuel</a> <a id="7055" href="SMT.Theory.Raw.Reflection.html#7055" class="Bound">Γ</a> <a id="7057" href="SMT.Theory.Raw.Reflection.html#7057" class="Bound">fv</a> <a id="7060" class="Symbol">(</a><a id="7061" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="7065" class="Symbol">(</a><a id="7066" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="7075" href="Agda.Builtin.Reflection.html#2771" class="InductiveConstructor">hidden</a>    <a id="7085" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="7095" class="Symbol">)</a> <a id="7097" href="SMT.Theory.Raw.Reflection.html#7097" class="Bound">t</a> <a id="7099" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7101" href="SMT.Theory.Raw.Reflection.html#7101" class="Bound">ts</a><a id="7103" class="Symbol">)</a> <a id="7105" class="Symbol">=</a> <a id="7107" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="7124" href="SMT.Theory.Raw.Reflection.html#7050" class="Bound">fuel</a> <a id="7129" href="SMT.Theory.Raw.Reflection.html#7055" class="Bound">Γ</a> <a id="7131" href="SMT.Theory.Raw.Reflection.html#7057" class="Bound">fv</a> <a id="7134" href="SMT.Theory.Raw.Reflection.html#7101" class="Bound">ts</a>
  <a id="7139" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="7156" href="SMT.Theory.Raw.Reflection.html#7156" class="Bound">fuel</a> <a id="7161" href="SMT.Theory.Raw.Reflection.html#7161" class="Bound">Γ</a> <a id="7163" href="SMT.Theory.Raw.Reflection.html#7163" class="Bound">fv</a> <a id="7166" class="Symbol">(</a><a id="7167" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="7171" class="Symbol">(</a><a id="7172" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="7181" href="Agda.Builtin.Reflection.html#2778" class="InductiveConstructor">instance′</a> <a id="7191" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="7201" class="Symbol">)</a> <a id="7203" href="SMT.Theory.Raw.Reflection.html#7203" class="Bound">t</a> <a id="7205" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7207" href="SMT.Theory.Raw.Reflection.html#7207" class="Bound">ts</a><a id="7209" class="Symbol">)</a> <a id="7211" class="Symbol">=</a> <a id="7213" href="SMT.Theory.Raw.Reflection.html#6502" class="Function">reflectToRawArgs</a> <a id="7230" href="SMT.Theory.Raw.Reflection.html#7156" class="Bound">fuel</a> <a id="7235" href="SMT.Theory.Raw.Reflection.html#7161" class="Bound">Γ</a> <a id="7237" href="SMT.Theory.Raw.Reflection.html#7163" class="Bound">fv</a> <a id="7240" href="SMT.Theory.Raw.Reflection.html#7207" class="Bound">ts</a>

<a id="7244" class="Comment">-- |Decode a reflected Agda type to a raw SMT-LIB script.</a>
<a id="7302" class="Comment">--</a>
<a id="7305" class="Comment">--  Functions are decoded as a series of assertions, with the result type</a>
<a id="7379" class="Comment">--  negated. For instance, the type `(x y : ℤ) → x - y ≤ x + y → x ≡ y`</a>
<a id="7451" class="Comment">--  is decoded as:</a>
<a id="7470" class="Comment">--</a>
<a id="7473" class="Comment">--  @</a>
<a id="7479" class="Comment">--    (declare-const ⋆ x)</a>
<a id="7505" class="Comment">--    (declare-const ⋆ y)</a>
<a id="7531" class="Comment">--    (assert (≤ (- x y) (+ x y)))</a>
<a id="7566" class="Comment">--    (assert (not (= x y)))</a>
<a id="7595" class="Comment">--  @</a>
<a id="7601" class="Comment">--</a>
<a id="7604" class="Comment">--  Which corresponds to `∃[ x ] ∃[ y ] (x - y ≤ x + y × x ≢ y)`, i.e.,</a>
<a id="7676" class="Comment">--  the negation of the Agda type. If the solver can find an inhabitant</a>
<a id="7748" class="Comment">--  for this type, then we have a counter-example for the original type.</a>
<a id="7821" class="Comment">--</a>
<a id="reflectToRawScript"></a><a id="7824" href="SMT.Theory.Raw.Reflection.html#7824" class="Function">reflectToRawScript</a> <a id="7843" class="Symbol">:</a> <a id="7845" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="7850" class="Symbol">→</a> <a id="7852" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="7855" class="Symbol">(</a><a id="7856" href="Data.Product.html#1806" class="Function">∃[</a> <a id="7859" href="SMT.Theory.Raw.Reflection.html#7859" class="Bound">Γ</a> <a id="7861" href="Data.Product.html#1806" class="Function">]</a> <a id="7863" href="SMT.Theory.Raw.Base.html#3811" class="Datatype">RawScript</a> <a id="7873" class="InductiveConstructor">[]</a> <a id="7876" href="SMT.Theory.Raw.Reflection.html#7859" class="Bound">Γ</a> <a id="7878" class="InductiveConstructor">[]</a><a id="7880" class="Symbol">)</a>
<a id="7882" href="SMT.Theory.Raw.Reflection.html#7824" class="Function">reflectToRawScript</a> <a id="7901" class="Symbol">=</a> <a id="7903" href="SMT.Theory.Raw.Reflection.html#7941" class="Function">reflectToRawScript′</a> <a id="7923" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="7926" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="7931" class="Keyword">where</a>
    <a id="7941" href="SMT.Theory.Raw.Reflection.html#7941" class="Function">reflectToRawScript′</a> <a id="7961" class="Symbol">:</a> <a id="7963" class="Symbol">(</a><a id="7964" href="SMT.Theory.Raw.Reflection.html#7964" class="Bound">Γ</a> <a id="7966" class="Symbol">:</a> <a id="7968" href="SMT.Theory.Raw.Base.html#3156" class="Function">RawCtxt</a><a id="7975" class="Symbol">)</a> <a id="7977" class="Symbol">(</a><a id="7978" href="SMT.Theory.Raw.Reflection.html#7978" class="Bound">fv</a> <a id="7981" class="Symbol">:</a> <a id="7983" href="SMT.Theory.Raw.Reflection.html#2646" class="Function">AllowedVars</a><a id="7994" class="Symbol">)</a> <a id="7996" class="Symbol">→</a> <a id="7998" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="8003" class="Symbol">→</a> <a id="8005" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="8008" class="Symbol">(</a><a id="8009" href="Data.Product.html#1806" class="Function">∃[</a> <a id="8012" href="SMT.Theory.Raw.Reflection.html#8012" class="Bound">Γ′</a> <a id="8015" href="Data.Product.html#1806" class="Function">]</a> <a id="8017" href="SMT.Theory.Raw.Base.html#3811" class="Datatype">RawScript</a> <a id="8027" href="SMT.Theory.Raw.Reflection.html#7964" class="Bound">Γ</a> <a id="8029" href="SMT.Theory.Raw.Reflection.html#8012" class="Bound">Γ′</a> <a id="8032" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="8034" class="Symbol">)</a>
    <a id="8040" href="SMT.Theory.Raw.Reflection.html#7941" class="Function">reflectToRawScript′</a> <a id="8060" href="SMT.Theory.Raw.Reflection.html#8060" class="Bound">Γ</a> <a id="8062" href="SMT.Theory.Raw.Reflection.html#8062" class="Bound">fv</a> <a id="8065" class="Symbol">(</a><a id="8066" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="8069" href="SMT.Theory.Raw.Reflection.html#8069" class="Bound">dom</a><a id="8072" class="Symbol">@(</a><a id="8074" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="8078" class="Symbol">_</a> <a id="8080" href="SMT.Theory.Raw.Reflection.html#8080" class="Bound">a</a><a id="8081" class="Symbol">)</a> <a id="8083" class="Symbol">(</a><a id="8084" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="8088" href="SMT.Theory.Raw.Reflection.html#8088" class="Bound">x</a> <a id="8090" href="SMT.Theory.Raw.Reflection.html#8090" class="Bound">b</a><a id="8091" class="Symbol">))</a> <a id="8094" class="Symbol">=</a>
      <a id="8102" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="8107" class="Number">0</a> <a id="8109" href="Reflection.DeBruijn.html#3864" class="Function Operator">∈FV</a> <a id="8113" href="SMT.Theory.Raw.Reflection.html#8090" class="Bound">b</a> <a id="8115" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="8118" class="Symbol">λ</a> <a id="8120" class="Keyword">where</a>
        <a id="8134" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="8139" class="Symbol">→</a> <a id="8141" class="Keyword">do</a>
          <a id="8154" href="SMT.Theory.Raw.Reflection.html#8154" class="Bound">Γ′</a> <a id="8157" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8159" href="SMT.Theory.Raw.Reflection.html#8159" class="Bound">s</a> <a id="8161" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="8163" href="Agda.Builtin.Reflection.html#8183" class="Postulate">extendContext</a> <a id="8177" href="SMT.Theory.Raw.Reflection.html#8069" class="Bound">dom</a> <a id="8181" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="8183" href="SMT.Theory.Raw.Reflection.html#7941" class="Function">reflectToRawScript′</a> <a id="8203" class="Symbol">(</a><a id="8204" href="SMT.Theory.Raw.Base.html#1521" class="InductiveConstructor">TERM</a> <a id="8209" href="SMT.Theory.Raw.Reflection.html#8080" class="Bound">a</a> <a id="8211" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8213" href="SMT.Theory.Raw.Reflection.html#8060" class="Bound">Γ</a><a id="8214" class="Symbol">)</a> <a id="8216" class="Symbol">(</a><a id="8217" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="8222" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8224" href="SMT.Theory.Raw.Reflection.html#8062" class="Bound">fv</a><a id="8226" class="Symbol">)</a> <a id="8228" href="SMT.Theory.Raw.Reflection.html#8090" class="Bound">b</a>
          <a id="8240" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="8247" class="Symbol">(</a><a id="8248" href="SMT.Theory.Raw.Reflection.html#8154" class="Bound">Γ′</a> <a id="8251" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8253" href="SMT.Theory.Raw.Base.html#3634" class="InductiveConstructor">`declare-constᵣ</a> <a id="8269" href="SMT.Theory.Raw.Reflection.html#8088" class="Bound">x</a> <a id="8271" class="Symbol">(</a><a id="8272" href="SMT.Theory.Raw.Base.html#1521" class="InductiveConstructor">TERM</a> <a id="8277" href="SMT.Theory.Raw.Reflection.html#8080" class="Bound">a</a><a id="8278" class="Symbol">)</a> <a id="8280" href="SMT.Theory.Raw.Base.html#3889" class="InductiveConstructor Operator">∷ᵣ</a> <a id="8283" href="SMT.Theory.Raw.Reflection.html#8159" class="Bound">s</a><a id="8284" class="Symbol">)</a>
        <a id="8294" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="8300" class="Symbol">→</a> <a id="8302" class="Keyword">do</a>
          <a id="8315" href="SMT.Theory.Raw.Reflection.html#8315" class="Bound">t</a> <a id="8317" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="8319" href="SMT.Theory.Raw.Reflection.html#4322" class="Function">reflectToRawTerm</a> <a id="8336" href="SMT.Theory.Raw.Reflection.html#8060" class="Bound">Γ</a> <a id="8338" href="SMT.Theory.Raw.Reflection.html#8062" class="Bound">fv</a> <a id="8341" href="SMT.Theory.Raw.Reflection.html#8080" class="Bound">a</a>
          <a id="8353" href="SMT.Theory.Raw.Reflection.html#8353" class="Bound">Γ′</a> <a id="8356" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8358" href="SMT.Theory.Raw.Reflection.html#8358" class="Bound">s</a> <a id="8360" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="8362" href="Agda.Builtin.Reflection.html#8183" class="Postulate">extendContext</a> <a id="8376" href="SMT.Theory.Raw.Reflection.html#8069" class="Bound">dom</a> <a id="8380" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="8382" href="SMT.Theory.Raw.Reflection.html#7941" class="Function">reflectToRawScript′</a> <a id="8402" href="SMT.Theory.Raw.Reflection.html#8060" class="Bound">Γ</a> <a id="8404" class="Symbol">(</a><a id="8405" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="8411" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="8413" href="SMT.Theory.Raw.Reflection.html#8062" class="Bound">fv</a><a id="8415" class="Symbol">)</a> <a id="8417" href="SMT.Theory.Raw.Reflection.html#8090" class="Bound">b</a>
          <a id="8429" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="8436" class="Symbol">(</a><a id="8437" href="SMT.Theory.Raw.Reflection.html#8353" class="Bound">Γ′</a> <a id="8440" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8442" href="SMT.Theory.Raw.Base.html#3682" class="InductiveConstructor">`assertᵣ</a> <a id="8451" href="SMT.Theory.Raw.Reflection.html#8315" class="Bound">t</a> <a id="8453" href="SMT.Theory.Raw.Base.html#3889" class="InductiveConstructor Operator">∷ᵣ</a> <a id="8456" href="SMT.Theory.Raw.Reflection.html#8358" class="Bound">s</a><a id="8457" class="Symbol">)</a>
    <a id="8463" href="SMT.Theory.Raw.Reflection.html#7941" class="CatchallClause Function">reflectToRawScript′</a><a id="8482" class="CatchallClause"> </a><a id="8483" href="SMT.Theory.Raw.Reflection.html#8483" class="CatchallClause Bound">Γ</a><a id="8484" class="CatchallClause"> </a><a id="8485" href="SMT.Theory.Raw.Reflection.html#8485" class="CatchallClause Bound">fv</a><a id="8487" class="CatchallClause"> </a><a id="8488" href="SMT.Theory.Raw.Reflection.html#8488" class="CatchallClause Bound">t</a> <a id="8490" class="Symbol">=</a> <a id="8492" class="Keyword">do</a>
      <a id="8501" href="SMT.Theory.Raw.Reflection.html#8501" class="Bound">t</a> <a id="8503" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="8505" href="SMT.Theory.Raw.Reflection.html#4322" class="Function">reflectToRawTerm</a> <a id="8522" href="SMT.Theory.Raw.Reflection.html#8483" class="Bound">Γ</a> <a id="8524" href="SMT.Theory.Raw.Reflection.html#8485" class="Bound">fv</a> <a id="8527" href="SMT.Theory.Raw.Reflection.html#8488" class="Bound">t</a>
      <a id="8535" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="8542" class="Symbol">(</a><a id="8543" href="SMT.Theory.Raw.Reflection.html#8483" class="Bound">Γ</a> <a id="8545" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="8547" href="SMT.Theory.Raw.Base.html#3682" class="InductiveConstructor">`assertᵣ</a> <a id="8556" class="Symbol">(</a><a id="8557" href="SMT.Theory.Raw.Base.html#3349" class="InductiveConstructor">`appᵣ</a> <a id="8563" class="Symbol">(</a><a id="8564" class="Keyword">quote</a> <a id="8570" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="8572" class="Symbol">)</a> <a id="8574" class="Symbol">(</a><a id="8575" href="SMT.Theory.Raw.Reflection.html#8501" class="Bound">t</a> <a id="8577" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="8579" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="8581" class="Symbol">))</a> <a id="8584" href="SMT.Theory.Raw.Base.html#3889" class="InductiveConstructor Operator">∷ᵣ</a> <a id="8587" href="SMT.Theory.Raw.Base.html#3853" class="InductiveConstructor">[]ᵣ</a><a id="8590" class="Symbol">)</a>
</pre></body></html>