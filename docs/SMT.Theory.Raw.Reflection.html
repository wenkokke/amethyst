<!DOCTYPE HTML>
<html><head><meta charset="utf-8"><title>SMT.Theory.Raw.Reflection</title><link rel="stylesheet" href="Agda.css"></head><body><pre class="Agda"><a id="1" class="Keyword">module</a> <a id="8" href="SMT.Theory.Raw.Reflection.html" class="Module">SMT.Theory.Raw.Reflection</a> <a id="34" class="Keyword">where</a>

<a id="41" class="Keyword">open</a> <a id="46" class="Keyword">import</a> <a id="53" href="Category.Monad.html" class="Module">Category.Monad</a>
<a id="68" class="Keyword">open</a> <a id="73" class="Keyword">import</a> <a id="80" href="Data.Bool.html" class="Module">Data.Bool</a> <a id="90" class="Symbol">as</a> <a id="93" class="Module">Bool</a> <a id="98" class="Keyword">using</a> <a id="104" class="Symbol">(</a><a id="105" href="Agda.Builtin.Bool.html#163" class="Datatype">Bool</a><a id="109" class="Symbol">;</a> <a id="111" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a><a id="115" class="Symbol">;</a> <a id="117" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a><a id="122" class="Symbol">)</a>
<a id="124" class="Keyword">open</a> <a id="129" class="Keyword">import</a> <a id="136" href="Data.Fin.html" class="Module">Data.Fin</a> <a id="145" class="Symbol">as</a> <a id="148" class="Module">Fin</a> <a id="152" class="Keyword">using</a> <a id="158" class="Symbol">(</a><a id="159" href="Data.Fin.Base.html#1138" class="Datatype">Fin</a><a id="162" class="Symbol">;</a> <a id="164" href="Data.Fin.Base.html#1191" class="InductiveConstructor">suc</a><a id="167" class="Symbol">;</a> <a id="169" href="Data.Fin.Base.html#1160" class="InductiveConstructor">zero</a><a id="173" class="Symbol">)</a>
<a id="175" class="Keyword">open</a> <a id="180" class="Keyword">import</a> <a id="187" href="Data.Integer.html" class="Module">Data.Integer</a> <a id="200" class="Symbol">as</a> <a id="203" class="Module">Int</a> <a id="207" class="Keyword">using</a> <a id="213" class="Symbol">(</a><a id="214" href="Agda.Builtin.Int.html#246" class="Datatype">ℤ</a><a id="215" class="Symbol">;</a> <a id="217" href="Agda.Builtin.Int.html#264" class="InductiveConstructor">+_</a><a id="219" class="Symbol">;</a> <a id="221" href="Agda.Builtin.Int.html#291" class="InductiveConstructor">-[1+_]</a><a id="227" class="Symbol">)</a>
<a id="229" class="Keyword">open</a> <a id="234" class="Keyword">import</a> <a id="241" href="Data.List.html" class="Module">Data.List</a> <a id="251" class="Symbol">as</a> <a id="254" class="Module">List</a> <a id="259" class="Keyword">using</a> <a id="265" class="Symbol">(</a><a id="266" href="Agda.Builtin.List.html#148" class="Datatype">List</a><a id="270" class="Symbol">;</a> <a id="272" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">_∷_</a><a id="275" class="Symbol">;</a> <a id="277" href="Data.List.Base.html#9981" class="InductiveConstructor">[]</a><a id="279" class="Symbol">)</a>
<a id="281" class="Keyword">open</a> <a id="286" class="Keyword">import</a> <a id="293" href="Data.List.Relation.Unary.All.html" class="Module">Data.List.Relation.Unary.All</a> <a id="322" class="Keyword">using</a> <a id="328" class="Symbol">(</a><a id="329" href="Data.List.Relation.Unary.All.html#1397" class="Datatype">All</a><a id="332" class="Symbol">;</a> <a id="334" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">_∷_</a><a id="337" class="Symbol">;</a> <a id="339" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="341" class="Symbol">)</a>
<a id="343" class="Keyword">open</a> <a id="348" class="Keyword">import</a> <a id="355" href="Data.List.NonEmpty.html" class="Module">Data.List.NonEmpty</a> <a id="374" class="Symbol">as</a> <a id="377" class="Module">List⁺</a> <a id="383" class="Keyword">using</a> <a id="389" class="Symbol">(</a><a id="390" href="Data.List.NonEmpty.html#1318" class="Record">List⁺</a><a id="395" class="Symbol">;</a> <a id="397" href="Data.List.NonEmpty.html#1364" class="InductiveConstructor Operator">_∷_</a><a id="400" class="Symbol">)</a>
<a id="402" class="Keyword">open</a> <a id="407" class="Keyword">import</a> <a id="414" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="423" class="Symbol">as</a> <a id="426" class="Module">Nat</a> <a id="430" class="Keyword">using</a> <a id="436" class="Symbol">(</a><a id="437" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="438" class="Symbol">;</a> <a id="440" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a><a id="444" class="Symbol">;</a> <a id="446" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a><a id="449" class="Symbol">;</a> <a id="451" href="Data.Nat.Base.html#2735" class="Primitive Operator">_∸_</a><a id="454" class="Symbol">)</a>
<a id="456" class="Keyword">import</a> <a id="463" href="Data.Nat.Literals.html" class="Module">Data.Nat.Literals</a> <a id="481" class="Symbol">as</a> <a id="484" class="Module">NatLits</a> <a id="492" class="Keyword">using</a> <a id="498" class="Symbol">(</a><a id="499" href="Data.Nat.Literals.html#353" class="Function">number</a><a id="505" class="Symbol">)</a>
<a id="507" class="Keyword">open</a> <a id="512" class="Keyword">import</a> <a id="519" href="Data.Product.html" class="Module">Data.Product</a> <a id="532" class="Symbol">as</a> <a id="535" class="Module">Prod</a> <a id="540" class="Keyword">using</a> <a id="546" class="Symbol">(</a><a id="547" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="548" class="Symbol">;</a> <a id="550" href="Data.Product.html#1369" class="Function">∃</a><a id="551" class="Symbol">;</a> <a id="553" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="561" class="Symbol">;</a> <a id="563" href="Data.Product.html#1788" class="Function">∃-syntax</a><a id="571" class="Symbol">;</a> <a id="573" href="Data.Product.html#1167" class="Function Operator">_×_</a><a id="576" class="Symbol">;</a> <a id="578" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">_,_</a><a id="581" class="Symbol">;</a> <a id="583" href="Agda.Builtin.Sigma.html#252" class="Field">proj₁</a><a id="588" class="Symbol">;</a> <a id="590" href="Agda.Builtin.Sigma.html#264" class="Field">proj₂</a><a id="595" class="Symbol">)</a>
<a id="597" class="Keyword">open</a> <a id="602" class="Keyword">import</a> <a id="609" href="Data.String.html" class="Module">Data.String</a> <a id="621" class="Keyword">using</a> <a id="627" class="Symbol">(</a><a id="628" href="Agda.Builtin.String.html#336" class="Postulate">String</a><a id="634" class="Symbol">)</a>
<a id="636" class="Keyword">open</a> <a id="641" class="Keyword">import</a> <a id="648" href="Data.Unit.html" class="Module">Data.Unit</a> <a id="658" class="Symbol">as</a> <a id="661" class="Module">Unit</a> <a id="666" class="Keyword">using</a> <a id="672" class="Symbol">(</a><a id="673" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a><a id="674" class="Symbol">)</a>
<a id="676" class="Keyword">open</a> <a id="681" class="Keyword">import</a> <a id="688" href="Function.html" class="Module">Function</a>
<a id="697" class="Keyword">open</a> <a id="702" class="Keyword">import</a> <a id="709" href="Level.html" class="Module">Level</a> <a id="715" class="Keyword">using</a> <a id="721" class="Symbol">(</a><a id="722" href="Agda.Primitive.html#597" class="Postulate">Level</a><a id="727" class="Symbol">)</a>
<a id="729" class="Keyword">open</a> <a id="734" class="Keyword">import</a> <a id="741" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="779" class="Symbol">as</a> <a id="782" class="Module">PropEq</a> <a id="789" class="Keyword">using</a> <a id="795" class="Symbol">(</a><a id="796" href="Agda.Builtin.Equality.html#151" class="Datatype Operator">_≡_</a><a id="799" class="Symbol">;</a> <a id="801" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="805" class="Symbol">)</a>
<a id="807" class="Keyword">open</a> <a id="812" class="Keyword">import</a> <a id="819" href="Reflection.html" class="Module">Reflection</a> <a id="830" class="Symbol">as</a> <a id="833" class="Module">Rfl</a> <a id="837" class="Keyword">hiding</a> <a id="844" class="Symbol">(</a><a id="845" href="Agda.Builtin.Reflection.html#7543" class="Postulate">return</a><a id="851" class="Symbol">;</a> <a id="853" href="Reflection.TypeChecking.Monad.Syntax.html#682" class="Function Operator">_&gt;&gt;=_</a><a id="858" class="Symbol">)</a>
<a id="860" class="Keyword">import</a> <a id="867" href="Reflection.TypeChecking.Monad.Categorical.html" class="Module">Reflection.TypeChecking.Monad.Categorical</a> <a id="909" class="Symbol">as</a> <a id="912" class="Module">TC</a>
<a id="915" class="Keyword">open</a> <a id="920" class="Keyword">import</a> <a id="927" href="Reflection.DeBruijn.html" class="Module">Reflection.DeBruijn</a> <a id="947" class="Keyword">using</a> <a id="953" class="Symbol">(</a><a id="954" href="Reflection.DeBruijn.html#1924" class="Function">η-expand</a><a id="962" class="Symbol">;</a> <a id="964" href="Reflection.DeBruijn.html#3614" class="Function Operator">_∈FV_</a><a id="969" class="Symbol">)</a>
<a id="971" class="Keyword">open</a> <a id="976" class="Keyword">import</a> <a id="983" href="Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="1000" class="Keyword">using</a> <a id="1006" class="Symbol">(</a><a id="1007" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="1009" class="Symbol">;</a> <a id="1011" href="Relation.Nullary.html#1508" class="Record">Dec</a><a id="1014" class="Symbol">;</a> <a id="1016" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a><a id="1019" class="Symbol">;</a> <a id="1021" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a><a id="1023" class="Symbol">)</a>
<a id="1025" class="Keyword">open</a> <a id="1030" class="Keyword">import</a> <a id="1037" href="Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="1064" class="Keyword">using</a> <a id="1070" class="Symbol">(</a><a id="1071" href="Relation.Nullary.Decidable.Core.html#1027" class="Function">isYes</a><a id="1076" class="Symbol">)</a>
<a id="1078" class="Keyword">open</a> <a id="1083" class="Keyword">import</a> <a id="1090" href="SMT.Theory.html" class="Module">SMT.Theory</a>
<a id="1101" class="Keyword">open</a> <a id="1106" class="Keyword">import</a> <a id="1113" href="SMT.Theory.Raw.Base.html" class="Module">SMT.Theory.Raw.Base</a>

<a id="1134" class="Keyword">open</a> <a id="1139" class="Keyword">import</a> <a id="1146" href="Agda.Builtin.FromNat.html" class="Module">Agda.Builtin.FromNat</a>
<a id="1167" class="Keyword">open</a> <a id="1172" class="Keyword">import</a> <a id="1179" href="Agda.Builtin.FromNeg.html" class="Module">Agda.Builtin.FromNeg</a>

<a id="1201" class="Keyword">instance</a> <a id="1210" href="SMT.Theory.Raw.Reflection.html#1210" class="Function">_</a> <a id="1212" class="Symbol">=</a> <a id="1214" href="Data.Nat.Literals.html#353" class="Function">NatLits.number</a>

<a id="1230" class="Keyword">private</a>
  <a id="1240" class="Keyword">open</a> <a id="1245" class="Keyword">module</a> <a id="TCMonad"></a><a id="1252" href="SMT.Theory.Raw.Reflection.html#1252" class="Module">TCMonad</a> <a id="1260" class="Symbol">{</a><a id="1261" href="SMT.Theory.Raw.Reflection.html#1261" class="Bound">ℓ</a><a id="1262" class="Symbol">}</a> <a id="1264" class="Symbol">=</a> <a id="1266" href="Category.Monad.html#832" class="Module">Category.Monad.RawMonad</a> <a id="1290" class="Symbol">{</a><a id="1291" href="SMT.Theory.Raw.Reflection.html#1261" class="Bound">ℓ</a><a id="1292" class="Symbol">}</a> <a id="1294" href="Reflection.TypeChecking.Monad.Categorical.html#1061" class="Function">TC.monad</a> <a id="1303" class="Keyword">renaming</a> <a id="1312" class="Symbol">(</a><a id="1313" href="Category.Applicative.Indexed.html#1034" class="Function Operator">_⊛_</a> <a id="1317" class="Symbol">to</a> <a id="TCMonad._⊛_"></a><a id="1320" href="SMT.Theory.Raw.Reflection.html#1320" class="Function Operator">_&lt;*&gt;_</a><a id="1325" class="Symbol">)</a>

<a id="1328" class="Keyword">private</a>
  <a id="1338" class="Keyword">variable</a>
    <a id="1351" href="SMT.Theory.Raw.Reflection.html#1351" class="Generalizable">ℓ</a> <a id="1353" class="Symbol">:</a> <a id="1355" href="Agda.Primitive.html#597" class="Postulate">Level</a>
    <a id="1365" href="SMT.Theory.Raw.Reflection.html#1365" class="Generalizable">A</a> <a id="1367" class="Symbol">:</a> <a id="1369" href="Agda.Primitive.html#326" class="Primitive">Set</a> <a id="1373" href="SMT.Theory.Raw.Reflection.html#1351" class="Generalizable">ℓ</a>


<a id="1377" class="Keyword">private</a>
  <a id="1387" class="Comment">-- We don&#39;t know the type of raw function symbols, so just look at</a>
  <a id="1456" class="Comment">-- the arguments. Design decision: only keep visible arguments.</a>
  <a id="argTypes"></a><a id="1522" href="SMT.Theory.Raw.Reflection.html#1522" class="Function">argTypes</a> <a id="1531" class="Symbol">:</a> <a id="1533" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="1538" class="Symbol">(</a><a id="1539" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="1543" href="SMT.Theory.Raw.Reflection.html#1365" class="Generalizable">A</a><a id="1544" class="Symbol">)</a> <a id="1546" class="Symbol">→</a> <a id="1548" href="SMT.Theory.Base.html#489" class="Record">Signature</a> <a id="1558" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a>
  <a id="1562" href="SMT.Theory.Raw.Reflection.html#1522" class="Function">argTypes</a> <a id="1571" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>              <a id="1587" class="Symbol">.</a><a id="1588" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="1597" class="Symbol">=</a> <a id="1599" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>
  <a id="1604" href="SMT.Theory.Raw.Reflection.html#1522" class="Function">argTypes</a> <a id="1613" class="Symbol">(</a><a id="1614" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="1619" class="Symbol">_</a> <a id="1621" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1623" href="SMT.Theory.Raw.Reflection.html#1623" class="Bound">args</a><a id="1627" class="Symbol">)</a> <a id="1629" class="Symbol">.</a><a id="1630" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="1639" class="Symbol">=</a> <a id="1641" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a> <a id="1643" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1645" href="SMT.Theory.Raw.Reflection.html#1522" class="Function">argTypes</a> <a id="1654" href="SMT.Theory.Raw.Reflection.html#1623" class="Bound">args</a> <a id="1659" class="Symbol">.</a><a id="1660" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a>
  <a id="1671" href="SMT.Theory.Raw.Reflection.html#1522" class="CatchallClause Function">argTypes</a><a id="1679" class="CatchallClause"> </a><a id="1680" class="CatchallClause Symbol">(_</a><a id="1682" class="CatchallClause">      </a><a id="1688" href="Agda.Builtin.List.html#200" class="CatchallClause InductiveConstructor Operator">∷</a><a id="1689" class="CatchallClause"> </a><a id="1690" href="SMT.Theory.Raw.Reflection.html#1690" class="CatchallClause Bound">args</a><a id="1694" class="CatchallClause Symbol">)</a><a id="1695" class="CatchallClause"> </a><a id="1696" class="CatchallClause Symbol">.</a><a id="1697" href="SMT.Theory.Base.html#547" class="CatchallClause Field">ArgSorts</a> <a id="1706" class="Symbol">=</a>     <a id="1712" href="SMT.Theory.Raw.Reflection.html#1522" class="Function">argTypes</a> <a id="1721" href="SMT.Theory.Raw.Reflection.html#1690" class="Bound">args</a> <a id="1726" class="Symbol">.</a><a id="1727" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a>


<a id="reflectToRawVar"></a><a id="1738" href="SMT.Theory.Raw.Reflection.html#1738" class="Function">reflectToRawVar</a> <a id="1754" class="Symbol">:</a> <a id="1756" class="Symbol">(</a><a id="1757" href="SMT.Theory.Raw.Reflection.html#1757" class="Bound">Γ</a> <a id="1759" class="Symbol">:</a> <a id="1761" href="SMT.Theory.Raw.Base.html#2678" class="Function">RawCtxt</a><a id="1768" class="Symbol">)</a> <a id="1770" class="Symbol">(</a><a id="1771" href="SMT.Theory.Raw.Reflection.html#1771" class="Bound">n</a> <a id="1773" class="Symbol">:</a> <a id="1775" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="1776" class="Symbol">)</a> <a id="1778" class="Symbol">→</a> <a id="1780" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="1783" class="Symbol">(</a><a id="1784" href="Data.Product.html#1788" class="Function">∃[</a> <a id="1787" href="SMT.Theory.Raw.Reflection.html#1787" class="Bound">σ</a> <a id="1789" href="Data.Product.html#1788" class="Function">]</a> <a id="1791" class="Symbol">(</a><a id="1792" href="SMT.Theory.Raw.Reflection.html#1757" class="Bound">Γ</a> <a id="1794" href="SMT.Theory.Raw.Base.html#2716" class="Function Operator">∋ᵣ</a> <a id="1797" href="SMT.Theory.Raw.Reflection.html#1787" class="Bound">σ</a><a id="1798" class="Symbol">))</a>
<a id="1801" href="SMT.Theory.Raw.Reflection.html#1738" class="Function">reflectToRawVar</a> <a id="1817" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a>      <a id="1825" href="SMT.Theory.Raw.Reflection.html#1825" class="Bound">n</a>       <a id="1833" class="Symbol">=</a> <a id="1835" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="1848" class="String">&quot;Variable out of bounds&quot;</a>
<a id="1873" href="SMT.Theory.Raw.Reflection.html#1738" class="Function">reflectToRawVar</a> <a id="1889" class="Symbol">(</a><a id="1890" href="SMT.Theory.Raw.Reflection.html#1890" class="Bound">x</a> <a id="1892" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1894" href="SMT.Theory.Raw.Reflection.html#1894" class="Bound">Γ</a><a id="1895" class="Symbol">)</a> <a id="1897" href="Agda.Builtin.Nat.html#210" class="InductiveConstructor">zero</a>    <a id="1905" class="Symbol">=</a> <a id="1907" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="1914" class="Symbol">(_</a> <a id="1917" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1919" href="Data.Fin.Base.html#1160" class="InductiveConstructor">zero</a> <a id="1924" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1926" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="1930" class="Symbol">)</a>
<a id="1932" href="SMT.Theory.Raw.Reflection.html#1738" class="Function">reflectToRawVar</a> <a id="1948" class="Symbol">(</a><a id="1949" href="SMT.Theory.Raw.Reflection.html#1949" class="Bound">x</a> <a id="1951" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="1953" href="SMT.Theory.Raw.Reflection.html#1953" class="Bound">Γ</a><a id="1954" class="Symbol">)</a> <a id="1956" class="Symbol">(</a><a id="1957" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="1961" href="SMT.Theory.Raw.Reflection.html#1961" class="Bound">n</a><a id="1962" class="Symbol">)</a> <a id="1964" class="Symbol">=</a> <a id="1966" class="Keyword">do</a>
  <a id="1971" href="SMT.Theory.Raw.Reflection.html#1971" class="Bound">σ</a> <a id="1973" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1975" href="SMT.Theory.Raw.Reflection.html#1975" class="Bound">i</a> <a id="1977" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="1979" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a> <a id="1984" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="1986" href="SMT.Theory.Raw.Reflection.html#1738" class="Function">reflectToRawVar</a> <a id="2002" href="SMT.Theory.Raw.Reflection.html#1953" class="Bound">Γ</a> <a id="2004" href="SMT.Theory.Raw.Reflection.html#1961" class="Bound">n</a>
  <a id="2008" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2015" class="Symbol">(</a><a id="2016" href="SMT.Theory.Raw.Reflection.html#1971" class="Bound">σ</a> <a id="2018" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2020" href="Data.Fin.Base.html#1191" class="InductiveConstructor">suc</a> <a id="2024" href="SMT.Theory.Raw.Reflection.html#1975" class="Bound">i</a> <a id="2026" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="2028" href="Agda.Builtin.Equality.html#208" class="InductiveConstructor">refl</a><a id="2032" class="Symbol">)</a>


<a id="strengthenVar"></a><a id="2036" href="SMT.Theory.Raw.Reflection.html#2036" class="Function">strengthenVar</a> <a id="2050" class="Symbol">:</a> <a id="2052" class="Symbol">(</a><a id="2053" href="SMT.Theory.Raw.Reflection.html#2053" class="Bound">fv</a> <a id="2056" href="SMT.Theory.Raw.Reflection.html#2056" class="Bound">n</a> <a id="2058" class="Symbol">:</a> <a id="2060" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="2061" class="Symbol">)</a> <a id="2063" class="Symbol">→</a> <a id="2065" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="2068" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a>
<a id="2070" href="SMT.Theory.Raw.Reflection.html#2036" class="Function">strengthenVar</a> <a id="2084" href="SMT.Theory.Raw.Reflection.html#2084" class="Bound">fv</a> <a id="2087" href="SMT.Theory.Raw.Reflection.html#2087" class="Bound">n</a> <a id="2089" class="Symbol">=</a>
  <a id="2093" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="2098" href="SMT.Theory.Raw.Reflection.html#2087" class="Bound">n</a> <a id="2100" href="Data.Nat.Properties.html#8944" class="Function Operator">Nat.&lt;?</a> <a id="2107" href="SMT.Theory.Raw.Reflection.html#2084" class="Bound">fv</a> <a id="2110" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="2113" class="Symbol">λ</a> <a id="2115" class="Keyword">where</a>
    <a id="2125" class="Symbol">(</a><a id="2126" href="Relation.Nullary.html#1645" class="InductiveConstructor">yes</a> <a id="2130" class="Symbol">_)</a> <a id="2133" class="Symbol">→</a> <a id="2135" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="2148" class="String">&quot;Dependent quantification in term&quot;</a>
    <a id="2187" class="Symbol">(</a><a id="2188" href="Relation.Nullary.html#1682" class="InductiveConstructor">no</a> <a id="2191" class="Symbol">_)</a>  <a id="2195" class="Symbol">→</a> <a id="2197" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="2204" class="Symbol">(</a><a id="2205" href="SMT.Theory.Raw.Reflection.html#2087" class="Bound">n</a> <a id="2207" href="Data.Nat.Base.html#2735" class="Primitive Operator">∸</a> <a id="2209" href="SMT.Theory.Raw.Reflection.html#2084" class="Bound">fv</a><a id="2211" class="Symbol">)</a>

<a id="2214" class="Comment">-- Placeholder name used as a function symbol of type TERM _ → ⋆ to wrap variables.</a>
<a id="rawVar"></a><a id="2298" href="SMT.Theory.Raw.Reflection.html#2298" class="Function">rawVar</a> <a id="2305" class="Symbol">:</a> <a id="2307" href="Agda.Builtin.Unit.html#164" class="Record">⊤</a>
<a id="2309" href="SMT.Theory.Raw.Reflection.html#2298" class="Function">rawVar</a> <a id="2316" class="Symbol">=</a> <a id="2318" class="Symbol">_</a>

<a id="2321" class="Keyword">private</a>
  <a id="2331" class="Keyword">pattern</a> <a id="`fromNat"></a><a id="2339" href="SMT.Theory.Raw.Reflection.html#2339" class="InductiveConstructor">`fromNat</a> <a id="2348" class="Symbol">=</a> <a id="2350" class="Keyword">quote</a> <a id="2356" href="Agda.Builtin.FromNat.html#282" class="Field">Number.fromNat</a>
  <a id="2373" class="Keyword">pattern</a> <a id="`fromNeg"></a><a id="2381" href="SMT.Theory.Raw.Reflection.html#2381" class="InductiveConstructor">`fromNeg</a> <a id="2390" class="Symbol">=</a> <a id="2392" class="Keyword">quote</a> <a id="2398" href="Agda.Builtin.FromNeg.html#284" class="Field">Negative.fromNeg</a>

  <a id="2418" class="Keyword">pattern</a> <a id="`Σ"></a><a id="2426" href="SMT.Theory.Raw.Reflection.html#2426" class="InductiveConstructor">`Σ</a>  <a id="2430" href="SMT.Theory.Raw.Reflection.html#2471" class="Bound">a</a> <a id="2432" href="SMT.Theory.Raw.Reflection.html#2480" class="Bound">b</a> <a id="2434" class="Symbol">=</a> <a id="2436" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2440" class="Symbol">(</a><a id="2441" class="Keyword">quote</a> <a id="2447" href="Agda.Builtin.Sigma.html#166" class="Record">Σ</a><a id="2448" class="Symbol">)</a>        <a id="2457" class="Symbol">(_</a> <a id="2460" class="InductiveConstructor Operator">∷</a> <a id="2462" class="Symbol">_</a> <a id="2464" class="InductiveConstructor Operator">∷</a> <a id="2466" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="2471" href="SMT.Theory.Raw.Reflection.html#2471" class="Bound">a</a> <a id="2473" class="InductiveConstructor Operator">∷</a> <a id="2475" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="2480" href="SMT.Theory.Raw.Reflection.html#2480" class="Bound">b</a> <a id="2482" class="InductiveConstructor Operator">∷</a> <a id="2484" class="InductiveConstructor">[]</a><a id="2486" class="Symbol">)</a>
  <a id="2490" class="Keyword">pattern</a> <a id="`Σˢ"></a><a id="2498" href="SMT.Theory.Raw.Reflection.html#2498" class="InductiveConstructor">`Σˢ</a> <a id="2502" href="SMT.Theory.Raw.Reflection.html#2543" class="Bound">a</a> <a id="2504" href="SMT.Theory.Raw.Reflection.html#2552" class="Bound">b</a> <a id="2506" class="Symbol">=</a> <a id="2508" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2512" class="Symbol">(</a><a id="2513" class="Keyword">quote</a> <a id="2519" href="Data.Product.html#916" class="Function">Σ-syntax</a><a id="2527" class="Symbol">)</a> <a id="2529" class="Symbol">(_</a> <a id="2532" class="InductiveConstructor Operator">∷</a> <a id="2534" class="Symbol">_</a> <a id="2536" class="InductiveConstructor Operator">∷</a> <a id="2538" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="2543" href="SMT.Theory.Raw.Reflection.html#2543" class="Bound">a</a> <a id="2545" class="InductiveConstructor Operator">∷</a> <a id="2547" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="2552" href="SMT.Theory.Raw.Reflection.html#2552" class="Bound">b</a> <a id="2554" class="InductiveConstructor Operator">∷</a> <a id="2556" class="InductiveConstructor">[]</a><a id="2558" class="Symbol">)</a>
  <a id="2562" class="Keyword">pattern</a> <a id="`∃"></a><a id="2570" href="SMT.Theory.Raw.Reflection.html#2570" class="InductiveConstructor">`∃</a>  <a id="2574" href="SMT.Theory.Raw.Reflection.html#2615" class="Bound">a</a> <a id="2576" href="SMT.Theory.Raw.Reflection.html#2624" class="Bound">b</a> <a id="2578" class="Symbol">=</a> <a id="2580" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2584" class="Symbol">(</a><a id="2585" class="Keyword">quote</a> <a id="2591" href="Data.Product.html#1369" class="Function">∃</a><a id="2592" class="Symbol">)</a>        <a id="2601" class="Symbol">(_</a> <a id="2604" class="InductiveConstructor Operator">∷</a> <a id="2606" class="Symbol">_</a> <a id="2608" class="InductiveConstructor Operator">∷</a> <a id="2610" href="Reflection.Argument.html#1126" class="InductiveConstructor">hArg</a> <a id="2615" href="SMT.Theory.Raw.Reflection.html#2615" class="Bound">a</a> <a id="2617" class="InductiveConstructor Operator">∷</a> <a id="2619" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="2624" href="SMT.Theory.Raw.Reflection.html#2624" class="Bound">b</a> <a id="2626" class="InductiveConstructor Operator">∷</a> <a id="2628" class="InductiveConstructor">[]</a><a id="2630" class="Symbol">)</a>
  <a id="2634" class="Keyword">pattern</a> <a id="`∃ˢ"></a><a id="2642" href="SMT.Theory.Raw.Reflection.html#2642" class="InductiveConstructor">`∃ˢ</a> <a id="2646" href="SMT.Theory.Raw.Reflection.html#2687" class="Bound">a</a> <a id="2648" href="SMT.Theory.Raw.Reflection.html#2696" class="Bound">b</a> <a id="2650" class="Symbol">=</a> <a id="2652" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="2656" class="Symbol">(</a><a id="2657" class="Keyword">quote</a> <a id="2663" href="Data.Product.html#1788" class="Function">∃-syntax</a><a id="2671" class="Symbol">)</a> <a id="2673" class="Symbol">(_</a> <a id="2676" class="InductiveConstructor Operator">∷</a> <a id="2678" class="Symbol">_</a> <a id="2680" class="InductiveConstructor Operator">∷</a> <a id="2682" href="Reflection.Argument.html#1126" class="InductiveConstructor">hArg</a> <a id="2687" href="SMT.Theory.Raw.Reflection.html#2687" class="Bound">a</a> <a id="2689" class="InductiveConstructor Operator">∷</a> <a id="2691" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="2696" href="SMT.Theory.Raw.Reflection.html#2696" class="Bound">b</a> <a id="2698" class="InductiveConstructor Operator">∷</a> <a id="2700" class="InductiveConstructor">[]</a><a id="2702" class="Symbol">)</a>

<a id="2705" class="Keyword">mutual</a>
  <a id="2714" class="Comment">-- |To avoid having to deal with overloaded literals in the different theories (the dictionaries</a>
  <a id="2813" class="Comment">--  are hard to deal with), we normalise any calls to fromNat and fromNeg.  To convince the</a>
  <a id="2907" class="Comment">--  termination checker that this is fine there&#39;s a fuel parameter limiting how many nested</a>
  <a id="3001" class="Comment">--  normalisations we are allowed to do. Overloading will not create any nested calls to fromNat</a>
  <a id="3100" class="Comment">--  or fromNeg so it&#39;s enough to provide 1 fuel for this.</a>
  <a id="3160" class="Comment">--  However we also use the fuel when eta-expanding the predicate in existentials, and since these</a>
  <a id="3261" class="Comment">--  can be arbitrarily nested we need a reasonable amount of fuel.</a>
  <a id="reflectToRawTerm"></a><a id="3330" href="SMT.Theory.Raw.Reflection.html#3330" class="Function">reflectToRawTerm</a> <a id="3347" class="Symbol">:</a> <a id="3349" class="Symbol">(</a><a id="3350" href="SMT.Theory.Raw.Reflection.html#3350" class="Bound">Γ</a> <a id="3352" class="Symbol">:</a> <a id="3354" href="SMT.Theory.Raw.Base.html#2678" class="Function">RawCtxt</a><a id="3361" class="Symbol">)</a> <a id="3363" class="Symbol">(</a><a id="3364" href="SMT.Theory.Raw.Reflection.html#3364" class="Bound">fv</a> <a id="3367" class="Symbol">:</a> <a id="3369" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3370" class="Symbol">)</a> <a id="3372" class="Symbol">→</a> <a id="3374" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="3379" class="Symbol">→</a> <a id="3381" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="3384" class="Symbol">(</a><a id="3385" href="SMT.Theory.Raw.Base.html#2751" class="Datatype">RawTerm</a> <a id="3393" href="SMT.Theory.Raw.Reflection.html#3350" class="Bound">Γ</a> <a id="3395" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a><a id="3396" class="Symbol">)</a>
  <a id="3400" href="SMT.Theory.Raw.Reflection.html#3330" class="Function">reflectToRawTerm</a> <a id="3417" class="Symbol">=</a> <a id="3419" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="3437" class="Number">1000</a>

  <a id="reflectToRawTerm′"></a><a id="3445" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="3463" class="Symbol">:</a> <a id="3465" class="Symbol">(</a><a id="3466" href="SMT.Theory.Raw.Reflection.html#3466" class="Bound">fuel</a> <a id="3471" class="Symbol">:</a> <a id="3473" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3474" class="Symbol">)</a> <a id="3476" class="Symbol">(</a><a id="3477" href="SMT.Theory.Raw.Reflection.html#3477" class="Bound">Γ</a> <a id="3479" class="Symbol">:</a> <a id="3481" href="SMT.Theory.Raw.Base.html#2678" class="Function">RawCtxt</a><a id="3488" class="Symbol">)</a> <a id="3490" class="Symbol">(</a><a id="3491" href="SMT.Theory.Raw.Reflection.html#3491" class="Bound">fv</a> <a id="3494" class="Symbol">:</a> <a id="3496" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="3497" class="Symbol">)</a> <a id="3499" class="Symbol">→</a> <a id="3501" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="3506" class="Symbol">→</a> <a id="3508" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="3511" class="Symbol">(</a><a id="3512" href="SMT.Theory.Raw.Base.html#2751" class="Datatype">RawTerm</a> <a id="3520" href="SMT.Theory.Raw.Reflection.html#3477" class="Bound">Γ</a> <a id="3522" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a><a id="3523" class="Symbol">)</a>
  <a id="3527" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="3545" href="SMT.Theory.Raw.Reflection.html#3545" class="Bound">fuel</a> <a id="3550" href="SMT.Theory.Raw.Reflection.html#3550" class="Bound">Γ</a> <a id="3552" href="SMT.Theory.Raw.Reflection.html#3552" class="Bound">fv</a> <a id="3555" class="Symbol">(</a><a id="3556" href="Agda.Builtin.Reflection.html#4348" class="InductiveConstructor">var</a> <a id="3560" href="SMT.Theory.Raw.Reflection.html#3560" class="Bound">x</a> <a id="3562" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3564" class="Symbol">)</a> <a id="3566" class="Symbol">=</a> <a id="3568" class="Keyword">do</a>
    <a id="3575" href="SMT.Theory.Raw.Reflection.html#3575" class="Bound">σ</a> <a id="3577" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="3579" href="SMT.Theory.Raw.Reflection.html#3579" class="Bound">y</a> <a id="3581" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="3583" href="SMT.Theory.Raw.Reflection.html#1738" class="Function">reflectToRawVar</a> <a id="3599" href="SMT.Theory.Raw.Reflection.html#3550" class="Bound">Γ</a> <a id="3601" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="3605" href="SMT.Theory.Raw.Reflection.html#2036" class="Function">strengthenVar</a> <a id="3619" href="SMT.Theory.Raw.Reflection.html#3552" class="Bound">fv</a> <a id="3622" href="SMT.Theory.Raw.Reflection.html#3560" class="Bound">x</a>
    <a id="3628" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3635" class="Symbol">(</a><a id="3636" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="3641" class="Symbol">{</a><a id="3642" class="Argument">Σ</a> <a id="3644" class="Symbol">=</a> <a id="3646" class="Keyword">record</a><a id="3652" class="Symbol">{</a><a id="3653" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="3662" class="Symbol">=</a> <a id="3664" href="SMT.Theory.Raw.Reflection.html#3575" class="Bound">σ</a> <a id="3666" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="3668" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="3670" class="Symbol">}}</a> <a id="3673" class="Symbol">(</a><a id="3674" class="Keyword">quote</a> <a id="3680" href="SMT.Theory.Raw.Reflection.html#2298" class="Function">rawVar</a><a id="3686" class="Symbol">)</a> <a id="3688" class="Symbol">(</a><a id="3689" href="SMT.Theory.Raw.Base.html#2789" class="InductiveConstructor">varᵣ</a> <a id="3694" href="SMT.Theory.Raw.Reflection.html#3579" class="Bound">y</a> <a id="3696" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="3698" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="3700" class="Symbol">))</a>
  <a id="3705" href="SMT.Theory.Raw.Reflection.html#3445" class="CatchallClause Function">reflectToRawTerm′</a><a id="3722" class="CatchallClause"> </a><a id="3723" href="SMT.Theory.Raw.Reflection.html#3723" class="CatchallClause Bound">fuel</a><a id="3727" class="CatchallClause"> </a><a id="3728" href="SMT.Theory.Raw.Reflection.html#3728" class="CatchallClause Bound">Γ</a><a id="3729" class="CatchallClause"> </a><a id="3730" class="CatchallClause Symbol">_</a><a id="3731" class="CatchallClause">  </a><a id="3733" class="CatchallClause Symbol">(</a><a id="3734" href="Agda.Builtin.Reflection.html#4348" class="CatchallClause InductiveConstructor">var</a><a id="3737" class="CatchallClause"> </a><a id="3738" class="CatchallClause Symbol">_</a><a id="3739" class="CatchallClause"> </a><a id="3740" class="CatchallClause Symbol">_)</a>  <a id="3744" class="Symbol">=</a> <a id="3746" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="3759" class="String">&quot;Higher-order variable&quot;</a>
  <a id="3785" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="3803" href="SMT.Theory.Raw.Reflection.html#3803" class="Bound">fuel</a> <a id="3808" href="SMT.Theory.Raw.Reflection.html#3808" class="Bound">Γ</a> <a id="3810" class="Symbol">_</a>  <a id="3813" class="Symbol">(</a><a id="3814" href="Agda.Builtin.Reflection.html#4719" class="InductiveConstructor">lit</a> <a id="3818" href="SMT.Theory.Raw.Reflection.html#3818" class="Bound">l</a><a id="3819" class="Symbol">)</a>    <a id="3824" class="Symbol">=</a> <a id="3826" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="3833" class="Symbol">(</a><a id="3834" href="SMT.Theory.Raw.Base.html#2824" class="InductiveConstructor">litᵣ</a> <a id="3839" href="SMT.Theory.Raw.Reflection.html#3818" class="Bound">l</a><a id="3840" class="Symbol">)</a>
  <a id="3844" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="3862" class="Symbol">(</a><a id="3863" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3867" href="SMT.Theory.Raw.Reflection.html#3867" class="Bound">fuel</a><a id="3871" class="Symbol">)</a> <a id="3873" href="SMT.Theory.Raw.Reflection.html#3873" class="Bound">Γ</a> <a id="3875" href="SMT.Theory.Raw.Reflection.html#3875" class="Bound">fv</a> <a id="3878" href="SMT.Theory.Raw.Reflection.html#3878" class="Bound">t</a><a id="3879" class="Symbol">@(</a><a id="3881" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="3885" href="SMT.Theory.Raw.Reflection.html#2339" class="InductiveConstructor">`fromNat</a> <a id="3894" class="Symbol">_)</a> <a id="3897" class="Symbol">=</a> <a id="3899" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="3917" href="SMT.Theory.Raw.Reflection.html#3867" class="Bound">fuel</a> <a id="3922" href="SMT.Theory.Raw.Reflection.html#3873" class="Bound">Γ</a> <a id="3924" href="SMT.Theory.Raw.Reflection.html#3875" class="Bound">fv</a> <a id="3927" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="3931" href="Agda.Builtin.Reflection.html#7855" class="Postulate">normalise</a> <a id="3941" href="SMT.Theory.Raw.Reflection.html#3878" class="Bound">t</a>
  <a id="3945" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="3963" class="Symbol">(</a><a id="3964" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="3968" href="SMT.Theory.Raw.Reflection.html#3968" class="Bound">fuel</a><a id="3972" class="Symbol">)</a> <a id="3974" href="SMT.Theory.Raw.Reflection.html#3974" class="Bound">Γ</a> <a id="3976" href="SMT.Theory.Raw.Reflection.html#3976" class="Bound">fv</a> <a id="3979" href="SMT.Theory.Raw.Reflection.html#3979" class="Bound">t</a><a id="3980" class="Symbol">@(</a><a id="3982" href="Agda.Builtin.Reflection.html#4461" class="InductiveConstructor">def</a> <a id="3986" href="SMT.Theory.Raw.Reflection.html#2381" class="InductiveConstructor">`fromNeg</a> <a id="3995" class="Symbol">_)</a> <a id="3998" class="Symbol">=</a> <a id="4000" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4018" href="SMT.Theory.Raw.Reflection.html#3968" class="Bound">fuel</a> <a id="4023" href="SMT.Theory.Raw.Reflection.html#3974" class="Bound">Γ</a> <a id="4025" href="SMT.Theory.Raw.Reflection.html#3976" class="Bound">fv</a> <a id="4028" href="Category.Monad.Indexed.html#814" class="Function Operator">=&lt;&lt;</a> <a id="4032" href="Agda.Builtin.Reflection.html#7855" class="Postulate">normalise</a> <a id="4042" href="SMT.Theory.Raw.Reflection.html#3979" class="Bound">t</a>
  <a id="4046" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4064" class="Symbol">(</a><a id="4065" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4069" href="SMT.Theory.Raw.Reflection.html#4069" class="Bound">fuel</a><a id="4073" class="Symbol">)</a> <a id="4075" href="SMT.Theory.Raw.Reflection.html#4075" class="Bound">Γ</a> <a id="4077" href="SMT.Theory.Raw.Reflection.html#4077" class="Bound">fv</a> <a id="4080" class="Symbol">(</a><a id="4081" href="SMT.Theory.Raw.Reflection.html#2426" class="InductiveConstructor">`Σ</a>  <a id="4085" href="SMT.Theory.Raw.Reflection.html#4085" class="Bound">a</a> <a id="4087" href="SMT.Theory.Raw.Reflection.html#4087" class="Bound">b</a><a id="4088" class="Symbol">)</a> <a id="4090" class="Symbol">=</a> <a id="4092" href="SMT.Theory.Raw.Reflection.html#5052" class="Function">reflectExist</a> <a id="4105" href="SMT.Theory.Raw.Reflection.html#4069" class="Bound">fuel</a> <a id="4110" href="SMT.Theory.Raw.Reflection.html#4075" class="Bound">Γ</a> <a id="4112" href="SMT.Theory.Raw.Reflection.html#4077" class="Bound">fv</a> <a id="4115" href="SMT.Theory.Raw.Reflection.html#4085" class="Bound">a</a> <a id="4117" href="SMT.Theory.Raw.Reflection.html#4087" class="Bound">b</a>
  <a id="4121" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4139" class="Symbol">(</a><a id="4140" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4144" href="SMT.Theory.Raw.Reflection.html#4144" class="Bound">fuel</a><a id="4148" class="Symbol">)</a> <a id="4150" href="SMT.Theory.Raw.Reflection.html#4150" class="Bound">Γ</a> <a id="4152" href="SMT.Theory.Raw.Reflection.html#4152" class="Bound">fv</a> <a id="4155" class="Symbol">(</a><a id="4156" href="SMT.Theory.Raw.Reflection.html#2498" class="InductiveConstructor">`Σˢ</a> <a id="4160" href="SMT.Theory.Raw.Reflection.html#4160" class="Bound">a</a> <a id="4162" href="SMT.Theory.Raw.Reflection.html#4162" class="Bound">b</a><a id="4163" class="Symbol">)</a> <a id="4165" class="Symbol">=</a> <a id="4167" href="SMT.Theory.Raw.Reflection.html#5052" class="Function">reflectExist</a> <a id="4180" href="SMT.Theory.Raw.Reflection.html#4144" class="Bound">fuel</a> <a id="4185" href="SMT.Theory.Raw.Reflection.html#4150" class="Bound">Γ</a> <a id="4187" href="SMT.Theory.Raw.Reflection.html#4152" class="Bound">fv</a> <a id="4190" href="SMT.Theory.Raw.Reflection.html#4160" class="Bound">a</a> <a id="4192" href="SMT.Theory.Raw.Reflection.html#4162" class="Bound">b</a>
  <a id="4196" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4214" class="Symbol">(</a><a id="4215" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4219" href="SMT.Theory.Raw.Reflection.html#4219" class="Bound">fuel</a><a id="4223" class="Symbol">)</a> <a id="4225" href="SMT.Theory.Raw.Reflection.html#4225" class="Bound">Γ</a> <a id="4227" href="SMT.Theory.Raw.Reflection.html#4227" class="Bound">fv</a> <a id="4230" class="Symbol">(</a><a id="4231" href="SMT.Theory.Raw.Reflection.html#2570" class="InductiveConstructor">`∃</a>  <a id="4235" href="SMT.Theory.Raw.Reflection.html#4235" class="Bound">a</a> <a id="4237" href="SMT.Theory.Raw.Reflection.html#4237" class="Bound">b</a><a id="4238" class="Symbol">)</a> <a id="4240" class="Symbol">=</a> <a id="4242" href="SMT.Theory.Raw.Reflection.html#5052" class="Function">reflectExist</a> <a id="4255" href="SMT.Theory.Raw.Reflection.html#4219" class="Bound">fuel</a> <a id="4260" href="SMT.Theory.Raw.Reflection.html#4225" class="Bound">Γ</a> <a id="4262" href="SMT.Theory.Raw.Reflection.html#4227" class="Bound">fv</a> <a id="4265" href="SMT.Theory.Raw.Reflection.html#4235" class="Bound">a</a> <a id="4267" href="SMT.Theory.Raw.Reflection.html#4237" class="Bound">b</a>
  <a id="4271" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4289" class="Symbol">(</a><a id="4290" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4294" href="SMT.Theory.Raw.Reflection.html#4294" class="Bound">fuel</a><a id="4298" class="Symbol">)</a> <a id="4300" href="SMT.Theory.Raw.Reflection.html#4300" class="Bound">Γ</a> <a id="4302" href="SMT.Theory.Raw.Reflection.html#4302" class="Bound">fv</a> <a id="4305" class="Symbol">(</a><a id="4306" href="SMT.Theory.Raw.Reflection.html#2642" class="InductiveConstructor">`∃ˢ</a> <a id="4310" href="SMT.Theory.Raw.Reflection.html#4310" class="Bound">a</a> <a id="4312" href="SMT.Theory.Raw.Reflection.html#4312" class="Bound">b</a><a id="4313" class="Symbol">)</a> <a id="4315" class="Symbol">=</a> <a id="4317" href="SMT.Theory.Raw.Reflection.html#5052" class="Function">reflectExist</a> <a id="4330" href="SMT.Theory.Raw.Reflection.html#4294" class="Bound">fuel</a> <a id="4335" href="SMT.Theory.Raw.Reflection.html#4300" class="Bound">Γ</a> <a id="4337" href="SMT.Theory.Raw.Reflection.html#4302" class="Bound">fv</a> <a id="4340" href="SMT.Theory.Raw.Reflection.html#4310" class="Bound">a</a> <a id="4342" href="SMT.Theory.Raw.Reflection.html#4312" class="Bound">b</a>
  <a id="4346" href="SMT.Theory.Raw.Reflection.html#3445" class="CatchallClause Function">reflectToRawTerm′</a><a id="4363" class="CatchallClause"> </a><a id="4364" href="SMT.Theory.Raw.Reflection.html#4364" class="CatchallClause Bound">fuel</a><a id="4368" class="CatchallClause"> </a><a id="4369" href="SMT.Theory.Raw.Reflection.html#4369" class="CatchallClause Bound">Γ</a><a id="4370" class="CatchallClause"> </a><a id="4371" href="SMT.Theory.Raw.Reflection.html#4371" class="CatchallClause Bound">fv</a><a id="4373" class="CatchallClause"> </a><a id="4374" class="CatchallClause Symbol">(</a><a id="4375" href="Agda.Builtin.Reflection.html#4461" class="CatchallClause InductiveConstructor">def</a><a id="4378" class="CatchallClause"> </a><a id="4379" href="SMT.Theory.Raw.Reflection.html#4379" class="CatchallClause Bound">f</a><a id="4380" class="CatchallClause"> </a><a id="4381" href="SMT.Theory.Raw.Reflection.html#4381" class="CatchallClause Bound">ts</a><a id="4383" class="CatchallClause Symbol">)</a> <a id="4385" class="Symbol">=</a> <a id="4387" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="4392" class="Symbol">{</a><a id="4393" class="Argument">Σ</a> <a id="4395" class="Symbol">=</a> <a id="4397" href="SMT.Theory.Raw.Reflection.html#1522" class="Function">argTypes</a> <a id="4406" href="SMT.Theory.Raw.Reflection.html#4381" class="Bound">ts</a><a id="4408" class="Symbol">}</a> <a id="4410" href="SMT.Theory.Raw.Reflection.html#4379" class="Bound">f</a> <a id="4412" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="4416" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="4433" href="SMT.Theory.Raw.Reflection.html#4364" class="Bound">fuel</a> <a id="4438" href="SMT.Theory.Raw.Reflection.html#4369" class="Bound">Γ</a> <a id="4440" href="SMT.Theory.Raw.Reflection.html#4371" class="Bound">fv</a> <a id="4443" href="SMT.Theory.Raw.Reflection.html#4381" class="Bound">ts</a>
  <a id="4448" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4466" href="SMT.Theory.Raw.Reflection.html#4466" class="Bound">fuel</a> <a id="4471" href="SMT.Theory.Raw.Reflection.html#4471" class="Bound">Γ</a> <a id="4473" href="SMT.Theory.Raw.Reflection.html#4473" class="Bound">fv</a> <a id="4476" class="Symbol">(</a><a id="4477" href="Agda.Builtin.Reflection.html#4404" class="InductiveConstructor">con</a> <a id="4481" href="SMT.Theory.Raw.Reflection.html#4481" class="Bound">c</a> <a id="4483" href="SMT.Theory.Raw.Reflection.html#4483" class="Bound">ts</a><a id="4485" class="Symbol">)</a> <a id="4487" class="Symbol">=</a> <a id="4489" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="4494" class="Symbol">{</a><a id="4495" class="Argument">Σ</a> <a id="4497" class="Symbol">=</a> <a id="4499" href="SMT.Theory.Raw.Reflection.html#1522" class="Function">argTypes</a> <a id="4508" href="SMT.Theory.Raw.Reflection.html#4483" class="Bound">ts</a><a id="4510" class="Symbol">}</a> <a id="4512" href="SMT.Theory.Raw.Reflection.html#4481" class="Bound">c</a> <a id="4514" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="4518" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="4535" href="SMT.Theory.Raw.Reflection.html#4466" class="Bound">fuel</a> <a id="4540" href="SMT.Theory.Raw.Reflection.html#4471" class="Bound">Γ</a> <a id="4542" href="SMT.Theory.Raw.Reflection.html#4473" class="Bound">fv</a> <a id="4545" href="SMT.Theory.Raw.Reflection.html#4483" class="Bound">ts</a>
  <a id="4550" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4568" href="SMT.Theory.Raw.Reflection.html#4568" class="Bound">fuel</a> <a id="4573" href="SMT.Theory.Raw.Reflection.html#4573" class="Bound">Γ</a> <a id="4575" href="SMT.Theory.Raw.Reflection.html#4575" class="Bound">fv</a> <a id="4578" class="Symbol">(</a><a id="4579" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="4582" class="Symbol">(</a><a id="4583" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="4587" class="Symbol">_</a> <a id="4589" href="SMT.Theory.Raw.Reflection.html#4589" class="Bound">a</a><a id="4590" class="Symbol">)</a> <a id="4592" class="Symbol">(</a><a id="4593" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="4597" href="SMT.Theory.Raw.Reflection.html#4597" class="Bound">x</a> <a id="4599" href="SMT.Theory.Raw.Reflection.html#4599" class="Bound">b</a><a id="4600" class="Symbol">))</a> <a id="4603" class="Symbol">=</a> <a id="4605" class="Keyword">do</a>
    <a id="4612" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="4617" class="Number">0</a> <a id="4619" href="Reflection.DeBruijn.html#3614" class="Function Operator">∈FV</a> <a id="4623" href="SMT.Theory.Raw.Reflection.html#4599" class="Bound">b</a> <a id="4625" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="4628" class="Symbol">λ</a> <a id="4630" class="Keyword">where</a>
      <a id="4642" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a>  <a id="4648" class="Symbol">→</a>
        <a id="4658" href="SMT.Theory.Raw.Base.html#2894" class="InductiveConstructor">forAllᵣ</a> <a id="4666" href="SMT.Theory.Raw.Reflection.html#4597" class="Bound">x</a> <a id="4668" class="Symbol">(</a><a id="4669" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="4674" href="SMT.Theory.Raw.Reflection.html#4589" class="Bound">a</a><a id="4675" class="Symbol">)</a> <a id="4677" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="4681" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4699" href="SMT.Theory.Raw.Reflection.html#4568" class="Bound">fuel</a> <a id="4704" class="Symbol">(</a><a id="4705" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="4710" href="SMT.Theory.Raw.Reflection.html#4589" class="Bound">a</a> <a id="4712" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4714" href="SMT.Theory.Raw.Reflection.html#4573" class="Bound">Γ</a><a id="4715" class="Symbol">)</a> <a id="4717" href="SMT.Theory.Raw.Reflection.html#4575" class="Bound">fv</a> <a id="4720" href="SMT.Theory.Raw.Reflection.html#4599" class="Bound">b</a>
      <a id="4728" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="4734" class="Symbol">→</a> <a id="4736" class="Keyword">do</a>
        <a id="4747" href="SMT.Theory.Raw.Reflection.html#4747" class="Bound">a</a> <a id="4749" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4751" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4769" href="SMT.Theory.Raw.Reflection.html#4568" class="Bound">fuel</a> <a id="4774" href="SMT.Theory.Raw.Reflection.html#4573" class="Bound">Γ</a> <a id="4776" href="SMT.Theory.Raw.Reflection.html#4575" class="Bound">fv</a> <a id="4779" href="SMT.Theory.Raw.Reflection.html#4589" class="Bound">a</a>
        <a id="4789" href="SMT.Theory.Raw.Reflection.html#4789" class="Bound">b</a> <a id="4791" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="4793" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4811" href="SMT.Theory.Raw.Reflection.html#4568" class="Bound">fuel</a> <a id="4816" href="SMT.Theory.Raw.Reflection.html#4573" class="Bound">Γ</a> <a id="4818" class="Symbol">(</a><a id="4819" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="4823" href="SMT.Theory.Raw.Reflection.html#4575" class="Bound">fv</a><a id="4825" class="Symbol">)</a> <a id="4827" href="SMT.Theory.Raw.Reflection.html#4599" class="Bound">b</a>
        <a id="4837" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="4844" class="Symbol">(</a><a id="4845" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="4850" class="Symbol">{</a><a id="4851" class="Argument">Σ</a> <a id="4853" class="Symbol">=</a> <a id="4855" class="Keyword">record</a> <a id="4862" class="Symbol">{</a><a id="4863" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="4872" class="Symbol">=</a> <a id="4874" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a> <a id="4876" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4878" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a> <a id="4880" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="4882" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="4884" class="Symbol">}}</a> <a id="4887" class="Symbol">(</a><a id="4888" class="Keyword">quote</a> <a id="4894" href="Function.Core.html#646" class="Function">Morphism</a><a id="4902" class="Symbol">)</a> <a id="4904" class="Symbol">(</a><a id="4905" href="SMT.Theory.Raw.Reflection.html#4747" class="Bound">a</a> <a id="4907" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4909" href="SMT.Theory.Raw.Reflection.html#4789" class="Bound">b</a> <a id="4911" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="4913" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="4915" class="Symbol">))</a>
  <a id="4920" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="4938" href="SMT.Theory.Raw.Reflection.html#4938" class="Bound">fuel</a> <a id="4943" href="SMT.Theory.Raw.Reflection.html#4943" class="Bound">Γ</a> <a id="4945" href="SMT.Theory.Raw.Reflection.html#4945" class="Bound">fv</a> <a id="4948" class="Symbol">(</a><a id="4949" href="Agda.Builtin.Reflection.html#4754" class="InductiveConstructor">meta</a> <a id="4954" href="SMT.Theory.Raw.Reflection.html#4954" class="Bound">x</a> <a id="4956" class="Symbol">_)</a> <a id="4959" class="Symbol">=</a> <a id="4961" href="Agda.Builtin.Reflection.html#8569" class="Postulate">blockOnMeta</a> <a id="4973" href="SMT.Theory.Raw.Reflection.html#4954" class="Bound">x</a>
  <a id="4977" href="SMT.Theory.Raw.Reflection.html#3445" class="CatchallClause Function">reflectToRawTerm′</a><a id="4994" class="CatchallClause"> </a><a id="4995" href="SMT.Theory.Raw.Reflection.html#4995" class="CatchallClause Bound">fuel</a><a id="4999" class="CatchallClause"> </a><a id="5000" href="SMT.Theory.Raw.Reflection.html#5000" class="CatchallClause Bound">Γ</a><a id="5001" class="CatchallClause"> </a><a id="5002" href="SMT.Theory.Raw.Reflection.html#5002" class="CatchallClause Bound">fv</a><a id="5004" class="CatchallClause"> </a><a id="5005" href="SMT.Theory.Raw.Reflection.html#5005" class="CatchallClause Bound">t</a> <a id="5007" class="Symbol">=</a> <a id="5009" href="Reflection.TypeChecking.Format.html#2592" class="Function">typeErrorFmt</a> <a id="5022" class="String">&quot;reflectToRawTerm′ failed&quot;</a>

  <a id="reflectExist"></a><a id="5052" href="SMT.Theory.Raw.Reflection.html#5052" class="Function">reflectExist</a> <a id="5065" class="Symbol">:</a> <a id="5067" class="Symbol">(</a><a id="5068" href="SMT.Theory.Raw.Reflection.html#5068" class="Bound">fuel</a> <a id="5073" class="Symbol">:</a> <a id="5075" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="5076" class="Symbol">)</a> <a id="5078" class="Symbol">(</a><a id="5079" href="SMT.Theory.Raw.Reflection.html#5079" class="Bound">Γ</a> <a id="5081" class="Symbol">:</a> <a id="5083" href="SMT.Theory.Raw.Base.html#2678" class="Function">RawCtxt</a><a id="5090" class="Symbol">)</a> <a id="5092" class="Symbol">(</a><a id="5093" href="SMT.Theory.Raw.Reflection.html#5093" class="Bound">fv</a> <a id="5096" class="Symbol">:</a> <a id="5098" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="5099" class="Symbol">)</a> <a id="5101" class="Symbol">→</a> <a id="5103" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="5108" class="Symbol">→</a> <a id="5110" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="5115" class="Symbol">→</a> <a id="5117" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="5120" class="Symbol">(</a><a id="5121" href="SMT.Theory.Raw.Base.html#2751" class="Datatype">RawTerm</a> <a id="5129" href="SMT.Theory.Raw.Reflection.html#5079" class="Bound">Γ</a> <a id="5131" href="SMT.Theory.Raw.Base.html#1032" class="InductiveConstructor">⋆</a><a id="5132" class="Symbol">)</a>
  <a id="5136" href="SMT.Theory.Raw.Reflection.html#5052" class="Function">reflectExist</a> <a id="5149" href="SMT.Theory.Raw.Reflection.html#5149" class="Bound">fuel</a> <a id="5154" href="SMT.Theory.Raw.Reflection.html#5154" class="Bound">Γ</a> <a id="5156" href="SMT.Theory.Raw.Reflection.html#5156" class="Bound">fv</a> <a id="5159" href="SMT.Theory.Raw.Reflection.html#5159" class="Bound">a</a> <a id="5161" href="SMT.Theory.Raw.Reflection.html#5161" class="Bound">b</a> <a id="5163" class="Symbol">=</a> <a id="5165" class="Keyword">do</a>
    <a id="5172" href="Agda.Builtin.Reflection.html#4518" class="InductiveConstructor">lam</a> <a id="5176" class="Symbol">_</a> <a id="5178" class="Symbol">(</a><a id="5179" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="5183" href="SMT.Theory.Raw.Reflection.html#5183" class="Bound">x</a> <a id="5185" href="SMT.Theory.Raw.Reflection.html#5185" class="Bound">b</a><a id="5186" class="Symbol">)</a> <a id="5188" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="5190" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5197" href="Function.Base.html#1919" class="Function Operator">$</a> <a id="5199" href="Reflection.DeBruijn.html#1924" class="Function">η-expand</a> <a id="5208" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a> <a id="5216" href="SMT.Theory.Raw.Reflection.html#5161" class="Bound">b</a>
      <a id="5224" class="Keyword">where</a> <a id="5230" class="CatchallClause Symbol">_</a><a id="5231" class="CatchallClause"> </a><a id="5232" class="CatchallClause Symbol">→</a><a id="5233" class="CatchallClause"> </a><a id="5234" href="Reflection.TypeChecking.Format.html#2592" class="CatchallClause Function">typeErrorFmt</a><a id="5246" class="CatchallClause"> </a><a id="5247" class="CatchallClause String">&quot;reflectedToRawTerm′ failed to η-expand existential predicate&quot;</a>
    <a id="5314" href="SMT.Theory.Raw.Base.html#2932" class="InductiveConstructor">existsᵣ</a> <a id="5322" href="SMT.Theory.Raw.Reflection.html#5183" class="Bound">x</a> <a id="5324" class="Symbol">(</a><a id="5325" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="5330" href="SMT.Theory.Raw.Reflection.html#5159" class="Bound">a</a><a id="5331" class="Symbol">)</a> <a id="5333" href="Category.Functor.html#608" class="Function Operator">&lt;$&gt;</a> <a id="5337" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="5355" href="SMT.Theory.Raw.Reflection.html#5149" class="Bound">fuel</a> <a id="5360" class="Symbol">(</a><a id="5361" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="5366" href="SMT.Theory.Raw.Reflection.html#5159" class="Bound">a</a> <a id="5368" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5370" href="SMT.Theory.Raw.Reflection.html#5154" class="Bound">Γ</a><a id="5371" class="Symbol">)</a> <a id="5373" href="SMT.Theory.Raw.Reflection.html#5156" class="Bound">fv</a> <a id="5376" href="SMT.Theory.Raw.Reflection.html#5185" class="Bound">b</a>

  <a id="reflectToRawArgs"></a><a id="5381" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5398" class="Symbol">:</a> <a id="5400" class="Symbol">∀</a> <a id="5402" class="Symbol">(</a><a id="5403" href="SMT.Theory.Raw.Reflection.html#5403" class="Bound">fuel</a> <a id="5408" class="Symbol">:</a> <a id="5410" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="5411" class="Symbol">)</a> <a id="5413" href="SMT.Theory.Raw.Reflection.html#5413" class="Bound">Γ</a> <a id="5415" class="Symbol">(</a><a id="5416" href="SMT.Theory.Raw.Reflection.html#5416" class="Bound">fv</a> <a id="5419" class="Symbol">:</a> <a id="5421" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="5422" class="Symbol">)</a> <a id="5424" class="Symbol">(</a><a id="5425" href="SMT.Theory.Raw.Reflection.html#5425" class="Bound">ts</a> <a id="5428" class="Symbol">:</a> <a id="5430" href="Agda.Builtin.List.html#148" class="Datatype">List</a> <a id="5435" class="Symbol">(</a><a id="5436" href="Agda.Builtin.Reflection.html#3255" class="Datatype">Arg</a> <a id="5440" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a><a id="5444" class="Symbol">))</a> <a id="5447" class="Symbol">→</a> <a id="5449" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="5452" class="Symbol">(</a><a id="5453" href="SMT.Theory.Raw.Base.html#2970" class="Function">RawArgs</a> <a id="5461" href="SMT.Theory.Raw.Reflection.html#5413" class="Bound">Γ</a> <a id="5463" class="Symbol">(</a><a id="5464" href="SMT.Theory.Base.html#547" class="Field">ArgSorts</a> <a id="5473" class="Symbol">(</a><a id="5474" href="SMT.Theory.Raw.Reflection.html#1522" class="Function">argTypes</a> <a id="5483" href="SMT.Theory.Raw.Reflection.html#5425" class="Bound">ts</a><a id="5485" class="Symbol">)))</a>
  <a id="5491" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5508" href="SMT.Theory.Raw.Reflection.html#5508" class="Bound">fuel</a> <a id="5513" href="SMT.Theory.Raw.Reflection.html#5513" class="Bound">Γ</a> <a id="5515" href="SMT.Theory.Raw.Reflection.html#5515" class="Bound">fv</a> <a id="5518" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="5521" class="Symbol">=</a> <a id="5523" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="5530" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a>
  <a id="5535" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5552" href="SMT.Theory.Raw.Reflection.html#5552" class="Bound">fuel</a> <a id="5557" href="SMT.Theory.Raw.Reflection.html#5557" class="Bound">Γ</a> <a id="5559" href="SMT.Theory.Raw.Reflection.html#5559" class="Bound">fv</a> <a id="5562" class="Symbol">(</a><a id="5563" href="Reflection.Argument.html#1071" class="InductiveConstructor">vArg</a> <a id="5568" href="SMT.Theory.Raw.Reflection.html#5568" class="Bound">t</a> <a id="5570" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5572" href="SMT.Theory.Raw.Reflection.html#5572" class="Bound">ts</a><a id="5574" class="Symbol">)</a> <a id="5576" class="Symbol">=</a> <a id="5578" class="Symbol">⦇</a> <a id="5580" href="SMT.Theory.Raw.Reflection.html#3445" class="Function">reflectToRawTerm′</a> <a id="5598" href="SMT.Theory.Raw.Reflection.html#5552" class="Bound">fuel</a> <a id="5603" href="SMT.Theory.Raw.Reflection.html#5557" class="Bound">Γ</a> <a id="5605" href="SMT.Theory.Raw.Reflection.html#5559" class="Bound">fv</a> <a id="5608" href="SMT.Theory.Raw.Reflection.html#5568" class="Bound">t</a> <a id="5610" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="5612" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5629" href="SMT.Theory.Raw.Reflection.html#5552" class="Bound">fuel</a> <a id="5634" href="SMT.Theory.Raw.Reflection.html#5557" class="Bound">Γ</a> <a id="5636" href="SMT.Theory.Raw.Reflection.html#5559" class="Bound">fv</a> <a id="5639" href="SMT.Theory.Raw.Reflection.html#5572" class="Bound">ts</a> <a id="5642" class="Symbol">⦈</a>
  <a id="5646" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5663" href="SMT.Theory.Raw.Reflection.html#5663" class="Bound">fuel</a> <a id="5668" href="SMT.Theory.Raw.Reflection.html#5668" class="Bound">Γ</a> <a id="5670" href="SMT.Theory.Raw.Reflection.html#5670" class="Bound">fv</a> <a id="5673" class="Symbol">(</a><a id="5674" href="Reflection.Argument.html#1126" class="InductiveConstructor">hArg</a> <a id="5679" class="Symbol">_</a> <a id="5681" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5683" href="SMT.Theory.Raw.Reflection.html#5683" class="Bound">ts</a><a id="5685" class="Symbol">)</a> <a id="5687" class="Symbol">=</a> <a id="5689" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5706" href="SMT.Theory.Raw.Reflection.html#5663" class="Bound">fuel</a> <a id="5711" href="SMT.Theory.Raw.Reflection.html#5668" class="Bound">Γ</a> <a id="5713" href="SMT.Theory.Raw.Reflection.html#5670" class="Bound">fv</a> <a id="5716" href="SMT.Theory.Raw.Reflection.html#5683" class="Bound">ts</a>
  <a id="5721" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5738" href="SMT.Theory.Raw.Reflection.html#5738" class="Bound">fuel</a> <a id="5743" href="SMT.Theory.Raw.Reflection.html#5743" class="Bound">Γ</a> <a id="5745" href="SMT.Theory.Raw.Reflection.html#5745" class="Bound">fv</a> <a id="5748" class="Symbol">(</a><a id="5749" href="Reflection.Argument.html#1181" class="InductiveConstructor">iArg</a> <a id="5754" class="Symbol">_</a> <a id="5756" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5758" href="SMT.Theory.Raw.Reflection.html#5758" class="Bound">ts</a><a id="5760" class="Symbol">)</a> <a id="5762" class="Symbol">=</a> <a id="5764" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5781" href="SMT.Theory.Raw.Reflection.html#5738" class="Bound">fuel</a> <a id="5786" href="SMT.Theory.Raw.Reflection.html#5743" class="Bound">Γ</a> <a id="5788" href="SMT.Theory.Raw.Reflection.html#5745" class="Bound">fv</a> <a id="5791" href="SMT.Theory.Raw.Reflection.html#5758" class="Bound">ts</a>
  <a id="5796" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5813" href="SMT.Theory.Raw.Reflection.html#5813" class="Bound">fuel</a> <a id="5818" href="SMT.Theory.Raw.Reflection.html#5818" class="Bound">Γ</a> <a id="5820" href="SMT.Theory.Raw.Reflection.html#5820" class="Bound">fv</a> <a id="5823" class="Symbol">(</a><a id="5824" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="5828" class="Symbol">(</a><a id="5829" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="5838" href="Agda.Builtin.Reflection.html#2763" class="InductiveConstructor">visible</a>   <a id="5848" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="5858" class="Symbol">)</a> <a id="5860" class="Symbol">_</a> <a id="5862" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5864" href="SMT.Theory.Raw.Reflection.html#5864" class="Bound">ts</a><a id="5866" class="Symbol">)</a> <a id="5868" class="Symbol">=</a> <a id="5870" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5887" href="SMT.Theory.Raw.Reflection.html#5813" class="Bound">fuel</a> <a id="5892" href="SMT.Theory.Raw.Reflection.html#5818" class="Bound">Γ</a> <a id="5894" href="SMT.Theory.Raw.Reflection.html#5820" class="Bound">fv</a> <a id="5897" href="SMT.Theory.Raw.Reflection.html#5864" class="Bound">ts</a>
  <a id="5902" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5919" href="SMT.Theory.Raw.Reflection.html#5919" class="Bound">fuel</a> <a id="5924" href="SMT.Theory.Raw.Reflection.html#5924" class="Bound">Γ</a> <a id="5926" href="SMT.Theory.Raw.Reflection.html#5926" class="Bound">fv</a> <a id="5929" class="Symbol">(</a><a id="5930" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="5934" class="Symbol">(</a><a id="5935" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="5944" href="Agda.Builtin.Reflection.html#2771" class="InductiveConstructor">hidden</a>    <a id="5954" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="5964" class="Symbol">)</a> <a id="5966" href="SMT.Theory.Raw.Reflection.html#5966" class="Bound">t</a> <a id="5968" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="5970" href="SMT.Theory.Raw.Reflection.html#5970" class="Bound">ts</a><a id="5972" class="Symbol">)</a> <a id="5974" class="Symbol">=</a> <a id="5976" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="5993" href="SMT.Theory.Raw.Reflection.html#5919" class="Bound">fuel</a> <a id="5998" href="SMT.Theory.Raw.Reflection.html#5924" class="Bound">Γ</a> <a id="6000" href="SMT.Theory.Raw.Reflection.html#5926" class="Bound">fv</a> <a id="6003" href="SMT.Theory.Raw.Reflection.html#5970" class="Bound">ts</a>
  <a id="6008" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="6025" href="SMT.Theory.Raw.Reflection.html#6025" class="Bound">fuel</a> <a id="6030" href="SMT.Theory.Raw.Reflection.html#6030" class="Bound">Γ</a> <a id="6032" href="SMT.Theory.Raw.Reflection.html#6032" class="Bound">fv</a> <a id="6035" class="Symbol">(</a><a id="6036" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="6040" class="Symbol">(</a><a id="6041" href="Agda.Builtin.Reflection.html#3195" class="InductiveConstructor">arg-info</a> <a id="6050" href="Agda.Builtin.Reflection.html#2778" class="InductiveConstructor">instance′</a> <a id="6060" href="Agda.Builtin.Reflection.html#3029" class="InductiveConstructor">irrelevant</a><a id="6070" class="Symbol">)</a> <a id="6072" href="SMT.Theory.Raw.Reflection.html#6072" class="Bound">t</a> <a id="6074" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="6076" href="SMT.Theory.Raw.Reflection.html#6076" class="Bound">ts</a><a id="6078" class="Symbol">)</a> <a id="6080" class="Symbol">=</a> <a id="6082" href="SMT.Theory.Raw.Reflection.html#5381" class="Function">reflectToRawArgs</a> <a id="6099" href="SMT.Theory.Raw.Reflection.html#6025" class="Bound">fuel</a> <a id="6104" href="SMT.Theory.Raw.Reflection.html#6030" class="Bound">Γ</a> <a id="6106" href="SMT.Theory.Raw.Reflection.html#6032" class="Bound">fv</a> <a id="6109" href="SMT.Theory.Raw.Reflection.html#6076" class="Bound">ts</a>


<a id="6114" class="Comment">-- |Decode a reflected Agda type to a raw SMT-LIB script.</a>
<a id="6172" class="Comment">--</a>
<a id="6175" class="Comment">--  Functions are decoded as a series of assertions, with the result type</a>
<a id="6249" class="Comment">--  negated. For instance, the type `(x y : ℤ) → x - y ≤ x + y → x ≡ y`</a>
<a id="6321" class="Comment">--  is decoded as:</a>
<a id="6340" class="Comment">--</a>
<a id="6343" class="Comment">--  @</a>
<a id="6349" class="Comment">--    (declare-const ⋆ x)</a>
<a id="6375" class="Comment">--    (declare-const ⋆ y)</a>
<a id="6401" class="Comment">--    (assert (≤ (- x y) (+ x y)))</a>
<a id="6436" class="Comment">--    (assert (not (= x y)))</a>
<a id="6465" class="Comment">--  @</a>
<a id="6471" class="Comment">--</a>
<a id="6474" class="Comment">--  Which corresponds to `∃[ x ] ∃[ y ] (x - y ≤ x + y × x ≢ y)`, i.e.,</a>
<a id="6546" class="Comment">--  the negation of the Agda type. If the solver can find an inhabitant</a>
<a id="6618" class="Comment">--  for this type, then we have a counter-example for the original type.</a>
<a id="6691" class="Comment">--</a>
<a id="reflectToRawScript"></a><a id="6694" href="SMT.Theory.Raw.Reflection.html#6694" class="Function">reflectToRawScript</a> <a id="6713" class="Symbol">:</a> <a id="6715" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="6720" class="Symbol">→</a> <a id="6722" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="6725" class="Symbol">(</a><a id="6726" href="Data.Product.html#1788" class="Function">∃[</a> <a id="6729" href="SMT.Theory.Raw.Reflection.html#6729" class="Bound">Γ</a> <a id="6731" href="Data.Product.html#1788" class="Function">]</a> <a id="6733" href="SMT.Theory.Raw.Base.html#3255" class="Datatype">RawScript</a> <a id="6743" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="6746" href="SMT.Theory.Raw.Reflection.html#6729" class="Bound">Γ</a> <a id="6748" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="6750" class="Symbol">)</a>
<a id="6752" href="SMT.Theory.Raw.Reflection.html#6694" class="Function">reflectToRawScript</a> <a id="6771" class="Symbol">=</a> <a id="6773" href="SMT.Theory.Raw.Reflection.html#6810" class="Function">reflectToRawScript′</a> <a id="6793" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a> <a id="6796" class="Number">0</a>
  <a id="6800" class="Keyword">where</a>
    <a id="6810" href="SMT.Theory.Raw.Reflection.html#6810" class="Function">reflectToRawScript′</a> <a id="6830" class="Symbol">:</a> <a id="6832" class="Symbol">(</a><a id="6833" href="SMT.Theory.Raw.Reflection.html#6833" class="Bound">Γ</a> <a id="6835" class="Symbol">:</a> <a id="6837" href="SMT.Theory.Raw.Base.html#2678" class="Function">RawCtxt</a><a id="6844" class="Symbol">)</a> <a id="6846" class="Symbol">(</a><a id="6847" href="SMT.Theory.Raw.Reflection.html#6847" class="Bound">fv</a> <a id="6850" class="Symbol">:</a> <a id="6852" href="Agda.Builtin.Nat.html#192" class="Datatype">ℕ</a><a id="6853" class="Symbol">)</a> <a id="6855" class="Symbol">→</a> <a id="6857" href="Agda.Builtin.Reflection.html#4246" class="Datatype">Term</a> <a id="6862" class="Symbol">→</a> <a id="6864" href="Agda.Builtin.Reflection.html#7500" class="Postulate">TC</a> <a id="6867" class="Symbol">(</a><a id="6868" href="Data.Product.html#1788" class="Function">∃[</a> <a id="6871" href="SMT.Theory.Raw.Reflection.html#6871" class="Bound">Γ′</a> <a id="6874" href="Data.Product.html#1788" class="Function">]</a> <a id="6876" href="SMT.Theory.Raw.Base.html#3255" class="Datatype">RawScript</a> <a id="6886" href="SMT.Theory.Raw.Reflection.html#6833" class="Bound">Γ</a> <a id="6888" href="SMT.Theory.Raw.Reflection.html#6871" class="Bound">Γ′</a> <a id="6891" href="Agda.Builtin.List.html#185" class="InductiveConstructor">[]</a><a id="6893" class="Symbol">)</a>
    <a id="6899" href="SMT.Theory.Raw.Reflection.html#6810" class="Function">reflectToRawScript′</a> <a id="6919" href="SMT.Theory.Raw.Reflection.html#6919" class="Bound">Γ</a> <a id="6921" href="SMT.Theory.Raw.Reflection.html#6921" class="Bound">fv</a> <a id="6924" class="Symbol">(</a><a id="6925" href="Agda.Builtin.Reflection.html#4636" class="InductiveConstructor">pi</a> <a id="6928" class="Symbol">(</a><a id="6929" href="Agda.Builtin.Reflection.html#3291" class="InductiveConstructor">arg</a> <a id="6933" class="Symbol">_</a> <a id="6935" href="SMT.Theory.Raw.Reflection.html#6935" class="Bound">a</a><a id="6936" class="Symbol">)</a> <a id="6938" class="Symbol">(</a><a id="6939" href="Agda.Builtin.Reflection.html#3538" class="InductiveConstructor">abs</a> <a id="6943" href="SMT.Theory.Raw.Reflection.html#6943" class="Bound">x</a> <a id="6945" href="SMT.Theory.Raw.Reflection.html#6945" class="Bound">b</a><a id="6946" class="Symbol">))</a> <a id="6949" class="Symbol">=</a>
      <a id="6957" href="Function.Base.html#4121" class="Function Operator">case</a> <a id="6962" class="Number">0</a> <a id="6964" href="Reflection.DeBruijn.html#3614" class="Function Operator">∈FV</a> <a id="6968" href="SMT.Theory.Raw.Reflection.html#6945" class="Bound">b</a> <a id="6970" href="Function.Base.html#4121" class="Function Operator">of</a> <a id="6973" class="Symbol">λ</a> <a id="6975" class="Keyword">where</a>
        <a id="6989" href="Agda.Builtin.Bool.html#188" class="InductiveConstructor">true</a> <a id="6994" class="Symbol">→</a> <a id="6996" class="Keyword">do</a>
          <a id="7009" href="SMT.Theory.Raw.Reflection.html#7009" class="Bound">Γ′</a> <a id="7012" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7014" href="SMT.Theory.Raw.Reflection.html#7014" class="Bound">s</a> <a id="7016" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="7018" href="SMT.Theory.Raw.Reflection.html#6810" class="Function">reflectToRawScript′</a> <a id="7038" class="Symbol">(</a><a id="7039" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="7044" href="SMT.Theory.Raw.Reflection.html#6935" class="Bound">a</a> <a id="7046" href="Agda.Builtin.List.html#200" class="InductiveConstructor Operator">∷</a> <a id="7048" href="SMT.Theory.Raw.Reflection.html#6919" class="Bound">Γ</a><a id="7049" class="Symbol">)</a> <a id="7051" href="SMT.Theory.Raw.Reflection.html#6921" class="Bound">fv</a> <a id="7054" href="SMT.Theory.Raw.Reflection.html#6945" class="Bound">b</a>
          <a id="7066" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="7073" class="Symbol">(</a><a id="7074" href="SMT.Theory.Raw.Reflection.html#7009" class="Bound">Γ′</a> <a id="7077" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7079" href="SMT.Theory.Raw.Base.html#3090" class="InductiveConstructor">declare-constᵣ</a> <a id="7094" href="SMT.Theory.Raw.Reflection.html#6943" class="Bound">x</a> <a id="7096" class="Symbol">(</a><a id="7097" href="SMT.Theory.Raw.Base.html#1049" class="InductiveConstructor">TERM</a> <a id="7102" href="SMT.Theory.Raw.Reflection.html#6935" class="Bound">a</a><a id="7103" class="Symbol">)</a> <a id="7105" href="SMT.Theory.Raw.Base.html#3329" class="InductiveConstructor Operator">∷ᵣ</a> <a id="7108" href="SMT.Theory.Raw.Reflection.html#7014" class="Bound">s</a><a id="7109" class="Symbol">)</a>
        <a id="7119" href="Agda.Builtin.Bool.html#182" class="InductiveConstructor">false</a> <a id="7125" class="Symbol">→</a> <a id="7127" class="Keyword">do</a>
          <a id="7140" href="SMT.Theory.Raw.Reflection.html#7140" class="Bound">t</a> <a id="7142" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="7144" href="SMT.Theory.Raw.Reflection.html#3330" class="Function">reflectToRawTerm</a> <a id="7161" href="SMT.Theory.Raw.Reflection.html#6919" class="Bound">Γ</a> <a id="7163" href="SMT.Theory.Raw.Reflection.html#6921" class="Bound">fv</a> <a id="7166" href="SMT.Theory.Raw.Reflection.html#6935" class="Bound">a</a>
          <a id="7178" href="SMT.Theory.Raw.Reflection.html#7178" class="Bound">Γ′</a> <a id="7181" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7183" href="SMT.Theory.Raw.Reflection.html#7183" class="Bound">s</a> <a id="7185" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="7187" href="SMT.Theory.Raw.Reflection.html#6810" class="Function">reflectToRawScript′</a> <a id="7207" href="SMT.Theory.Raw.Reflection.html#6919" class="Bound">Γ</a> <a id="7209" class="Symbol">(</a><a id="7210" href="Agda.Builtin.Nat.html#223" class="InductiveConstructor">suc</a> <a id="7214" href="SMT.Theory.Raw.Reflection.html#6921" class="Bound">fv</a><a id="7216" class="Symbol">)</a> <a id="7218" href="SMT.Theory.Raw.Reflection.html#6945" class="Bound">b</a>
          <a id="7230" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="7237" class="Symbol">(</a><a id="7238" href="SMT.Theory.Raw.Reflection.html#7178" class="Bound">Γ′</a> <a id="7241" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7243" href="SMT.Theory.Raw.Base.html#3135" class="InductiveConstructor">assertᵣ</a> <a id="7251" href="SMT.Theory.Raw.Reflection.html#7140" class="Bound">t</a> <a id="7253" href="SMT.Theory.Raw.Base.html#3329" class="InductiveConstructor Operator">∷ᵣ</a> <a id="7256" href="SMT.Theory.Raw.Reflection.html#7183" class="Bound">s</a><a id="7257" class="Symbol">)</a>
    <a id="7263" href="SMT.Theory.Raw.Reflection.html#6810" class="CatchallClause Function">reflectToRawScript′</a><a id="7282" class="CatchallClause"> </a><a id="7283" href="SMT.Theory.Raw.Reflection.html#7283" class="CatchallClause Bound">Γ</a><a id="7284" class="CatchallClause"> </a><a id="7285" href="SMT.Theory.Raw.Reflection.html#7285" class="CatchallClause Bound">fv</a><a id="7287" class="CatchallClause"> </a><a id="7288" href="SMT.Theory.Raw.Reflection.html#7288" class="CatchallClause Bound">t</a> <a id="7290" class="Symbol">=</a> <a id="7292" class="Keyword">do</a>
      <a id="7301" href="SMT.Theory.Raw.Reflection.html#7301" class="Bound">t</a> <a id="7303" href="Category.Monad.Indexed.html#677" class="Function Operator">←</a> <a id="7305" href="SMT.Theory.Raw.Reflection.html#3330" class="Function">reflectToRawTerm</a> <a id="7322" href="SMT.Theory.Raw.Reflection.html#7283" class="Bound">Γ</a> <a id="7324" href="SMT.Theory.Raw.Reflection.html#7285" class="Bound">fv</a> <a id="7327" href="SMT.Theory.Raw.Reflection.html#7288" class="Bound">t</a>
      <a id="7335" href="Category.Monad.Indexed.html#644" class="Function">return</a> <a id="7342" class="Symbol">(</a><a id="7343" href="SMT.Theory.Raw.Reflection.html#7283" class="Bound">Γ</a> <a id="7345" href="Agda.Builtin.Sigma.html#236" class="InductiveConstructor Operator">,</a> <a id="7347" href="SMT.Theory.Raw.Base.html#3135" class="InductiveConstructor">assertᵣ</a> <a id="7355" class="Symbol">(</a><a id="7356" href="SMT.Theory.Raw.Base.html#2859" class="InductiveConstructor">appᵣ</a> <a id="7361" class="Symbol">(</a><a id="7362" class="Keyword">quote</a> <a id="7368" href="Relation.Nullary.html#653" class="Function Operator">¬_</a><a id="7370" class="Symbol">)</a> <a id="7372" class="Symbol">(</a><a id="7373" href="SMT.Theory.Raw.Reflection.html#7301" class="Bound">t</a> <a id="7375" href="Data.List.Relation.Unary.All.html#1477" class="InductiveConstructor Operator">∷</a> <a id="7377" href="Data.List.Relation.Unary.All.html#1460" class="InductiveConstructor">[]</a><a id="7379" class="Symbol">))</a> <a id="7382" href="SMT.Theory.Raw.Base.html#3329" class="InductiveConstructor Operator">∷ᵣ</a> <a id="7385" href="SMT.Theory.Raw.Base.html#3295" class="InductiveConstructor">[]ᵣ</a><a id="7388" class="Symbol">)</a>
</pre></body></html>